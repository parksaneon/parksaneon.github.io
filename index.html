<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14.0/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"parksaneon.github.io","root":"/","scheme":"Muse","version":"8.0.0-rc.5","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false};
  </script>

  <meta name="description" content="All Dev stories">
<meta property="og:type" content="website">
<meta property="og:title" content="Park facamp&#39;s blog">
<meta property="og:url" content="http://parksaneon.github.io/index.html">
<meta property="og:site_name" content="Park facamp&#39;s blog">
<meta property="og:description" content="All Dev stories">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Park facamp">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://parksaneon.github.io/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Park facamp's blog</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Park facamp's blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Park facamp</p>
  <div class="site-description" itemprop="description">All Dev stories</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">19</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



      </section>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">
      

      
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://parksaneon.github.io/2020/08/27/built-in-object/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Park facamp">
      <meta itemprop="description" content="All Dev stories">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Park facamp's blog">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/27/built-in-object/" class="post-title-link" itemprop="url">built in object</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-08-27 17:14:34 / Modified: 17:17:34" itemprop="dateCreated datePublished" datetime="2020-08-27T17:14:34+09:00">2020-08-27</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Built-in-Object-빌트-인-객체"><a href="#Built-in-Object-빌트-인-객체" class="headerlink" title="Built in Object ( 빌트 인 객체 )"></a>Built in Object ( 빌트 인 객체 )</h1><p>JS 객체의 정류 </p>
<ol>
<li>표준 빌트인 객체  : ECMAScript 사양에 정의된 객체로서, 애플리케이션 전역의 공통 기능을 제공</li>
</ol>
<p>​    빌트인 객체는 ECMAScript 사양에 정의된 객체이므로 자바스크립트 실행 환경(브라우저 또는 Node.js 환경)과 관계없이 언제나 사용할 수 있다. 표준 빌트인 객    체는 전역 객체의 프로퍼티로서 제공된다. 따라서 별도의 선언 없이 전역 변수처럼 언제나 참조할 수 있다.</p>
<ol start="2">
<li><p>호스트 객체 : ECMAScript 사양에 정의되어 있지 않지만 <strong>자바스크립트 실행 환경(브라우저 환경 또는 Node.js 환경 등에서 에서 추가로 제공하는 객체</strong>     </p>
</li>
<li><p>사용자 정의 객체 : <strong>사용자가 직접 정의</strong>한 객체</p>
</li>
</ol>
<h3 id="표준-빌트인-객체"><a href="#표준-빌트인-객체" class="headerlink" title="표준 빌트인 객체"></a>표준 빌트인 객체</h3><p>자바스크립트는 Object, String, Number, Boolean, Symbol, Date, Math, RegExp, Array, Map/Set, WeakMap/WeakSet, Function, Promise, Reflect, Proxy, JSON, Error 등의 빌트인 객체를 제공한다.</p>
<p>Math, Reflect, JSON을 제외한 표준 빌트인 객체는 모두 인스턴스를 생성할 수 있는 생성자 함수 객체다. 생성자 함수 객체인 표준 빌트인 객체는 프로토타입 메서드와 정적 메소드를 제공하고 생성자 함수 객체가 아닌 표준 빌트인 객체는 정적 메소드만 제공한다.</p>
<p>예를 들어, 표준 빌트인 객체인 String, Number, Boolean, Function, Array, Date는 생성자 함수로 호출하여 인스턴스를 생성할 수 있다.</p>
<p>생성자 함수인 표준 빌트인 객체가 생성한 인스턴스의 프로토타입은 표준 빌트인 객체의 prototype 프로퍼티에 바인딩된 객체이다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// String 생성자 함수에 의한 String 객체 생성</span></span><br><span class="line"><span class="keyword">const</span> strObj = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&#x27;Lee&#x27;</span>); <span class="comment">// String &#123;&quot;Lee&quot;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// String 생성자 함수를 통해 생성한 strObj 객체의 프로토타입은 String.prototype이다.</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(strObj) === <span class="built_in">String</span>.prototype); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>



<h3 id="원시값-래퍼-객체"><a href="#원시값-래퍼-객체" class="headerlink" title="원시값 / 래퍼 객체"></a>원시값 / 래퍼 객체</h3><p>문자열이나 숫자, 불리언 등의 원시값이 있는데도 문자열, 숫자, 불리언 객체를 생성하는 String, Number, Boolean 등의 표준 빌트인 생성자 함수가 존재한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 원시 타입인 문자열이 프로퍼티와 메서드를 갖고 있는 객체처럼 동작한다.</span></span><br><span class="line"><span class="built_in">console</span>.log(str.length); <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(str.toUpperCase()); <span class="comment">// HELLO</span></span><br></pre></td></tr></table></figure>

<p>위의 예시에서 원시값은 객체가 아니므로 프로퍼티나 메서드를 가질 수 없는데도 원시값인 문자열이 마치 객체처럼 동작한다.</p>
<p>원시값인 문자열, 숫자, 불리언 값의 경우 이들 원시값에 대해 마치 객체처럼 마침표 표기법(또는 대괄호 표기법)으로 접근하면, <strong>자바스크립트 엔진이 일시적으로 원시값을 연관된 객체로 변환</strong>해 주기 때문이다.</p>
<p>원시값을 객체처럼 사용하면 <strong>자바스크립트 엔진은 암묵적으로 연관된 객체를 생성하여 생성된 객체로 프로퍼티에 접근하거나 메서드를 호출하고 다시 원시값으로 되돌린다.</strong></p>
<p>문자열, 숫자, 불리언 값등 <strong>원시값에 대해 객체처럼 접근하면 생성되는</strong> <strong>임시 객체를 래퍼 객체</strong>라고 한다.</p>
<p>원시값에 마침표 표기법 사용 -&gt; 일시적으로 해당 원시값에 연관된 객체로 변호나 -&gt; 연관 객체로 프로퍼티/ 메소드에 접근 호출하고 다시 원시값으로 되돌림</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&#x27;hi&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 원시 타입인 문자열이 래퍼 객체인 String 인스턴스로 변환된다.</span></span><br><span class="line"><span class="built_in">console</span>.log(str.length); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(str.toUpperCase()); <span class="comment">// HI</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 래퍼 객체로 프로퍼티에 접근하거나 메서드를 호출한 후, 다시 원시값으로 되돌린다.</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> str); <span class="comment">// string</span></span><br></pre></td></tr></table></figure>

<p>문자열 래퍼 객체인 String 생성자 함수의 인스턴스는 String.prototype의 메서드를 상속받아 사용할 수 있다.</p>
<p>래퍼 객체의 처리가 종료되면 래퍼 객체의 [[StringData]] 내부 슬롯에 할당된 원시값으로 원래의 상태, 즉 식별자가 원시값을 갖도록 되돌리고 래퍼 객체는 가비지 컬렉션의 대상이 된다. </p>
<p>이는 숫자 타입 값이나 불리언 타입 값도 마찬가지다.</p>
<p>그리고 <strong>문자열, 숫자, 불리언, 심벌</strong> 이외의 원시값, 즉 null과 undefined는 래퍼 객체를 생성하지 않는다. 따라서 null과 undefined 값을 객체처럼 사용하면 에러가 발생한다.</p>
<h3 id="전역객체"><a href="#전역객체" class="headerlink" title="전역객체"></a>전역객체</h3><p>코드가 실행되기 이전 단계에 자바스크립트 엔진에 의해 어떤 객체보다도 먼저 생성되는 특수한 객체이며, 어떤 객체에도 속하지 않은 최상위 객체다.</p>
<p>브라우저 환경에서는 window(또는 self, this, frames)가 전역 객체를 가리키지만 Node.js 환경에서는 global이 전역 객체를 가리킨다.</p>
<p>전역 객체는 표준 빌트인 객체(Object, String, Number, Function, Array 등)와 환경에 따른 호스트 객체(클라이언트 web API 또는 Node.js의 호스트 API), 그리고 <strong>var 키워드로 선언한 전역 변수와 전역 함수를 프로퍼티로 갖는다.</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// var 키워드로 선언한 전역 변수</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.foo); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 선언하지 않은 변수에 값을 암묵적 전역. bar는 전역 변수가 아니라 전역 객체의 프로퍼티다.</span></span><br><span class="line">bar = <span class="number">2</span>; <span class="comment">// window.bar = 2</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.bar); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 전역 함수</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">3</span>; &#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.baz()); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>var키워드 외에 let이나 const 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 아니다.</p>
<p>전역객체는 다음과 같은 특징을 가진다.</p>
<ul>
<li><p>전역 객체는 개발자가 의도적으로 생성할 수 없다. 즉, 전역 객체를 생성할 수 있는 생성자 함수가 제공되지 않는다.</p>
</li>
<li><p>전역 객체의 프로퍼티를 참조할 때 window(또는 global)를 생략할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 전역 프로퍼티는 window를 생략하고 참조할 수 있다.</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.Infinity === <span class="literal">Infinity</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://parksaneon.github.io/2020/08/27/strict-mod/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Park facamp">
      <meta itemprop="description" content="All Dev stories">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Park facamp's blog">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/27/strict-mod/" class="post-title-link" itemprop="url">strict mod</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-08-27 17:14:11 / Modified: 17:17:05" itemprop="dateCreated datePublished" datetime="2020-08-27T17:14:11+09:00">2020-08-27</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="strict-mod"><a href="#strict-mod" class="headerlink" title="strict mod"></a>strict mod</h1><p>자바스크립트는 사용자가 실수로 작성한 코드를 암묵적으로 변환하여 오류의 발생을 줄인다. 얼핏보면 장점으로 보이나 장기적인 관점에서 봤을 때 의도치 않은 에러가 발생할 수 있다.</p>
<p>이를 방지하기 위해 strict mod를 사용한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 즉시 실행 함수의 선두에 strict mode 적용</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  &#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Do something...</span></span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure>

<p>혹 외부 라이브러리를 사용한다면 저역 환경에 strict mod를 사용하다간 충돌이 발생할 수 있으므로 즉시 실행함수 (function(){}()) 내부에 사용하는 것이 좋다.</p>
<h2 id="strict-를-사용한-후-변화"><a href="#strict-를-사용한-후-변화" class="headerlink" title="strict 를 사용한 후 변화"></a>strict 를 사용한 후 변화</h2><ol>
<li>선언하지 않은 변수를 참조하면 에러가 발생한다.</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  &#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  x = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(x); <span class="comment">// ReferenceError: x is not defined</span></span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure>

<p>원래 자바스크립트 엔진은 위의 상황에서 암묵적으로 전역 객체에 x 프로퍼티를 동적 생성한다.</p>
<p>strict 모드를 사용함으로서 선언하지 않은 변수 1이란 값을 할당한 상황에서 정의되지 않은 변수라고 에러를 발생시킨다.</p>
<ol start="2">
<li>delete 연산자</li>
</ol>
<p>delete 연산자로 변수, 함수, 매개변수를 삭제하면 SyntaxError가 발생한다.</p>
<ol start="3">
<li>매개변수 이름의 중복</li>
</ol>
<p>중복된 매개변수 이름을 사용하면 SyntaxError가 발생한다.</p>
<ol start="4">
<li>일반 함수의 this</li>
</ol>
<p>strict mode 에서 함수를 일반 함수로서 호출하면 this에 undefined가 바인딩된다. </p>
<p>원래 대로라면 window라는 전역 객체를 바인딩 한다.</p>
<ol start="5">
<li>arguments 객체</li>
</ol>
<p>매개변수에 전달된 인수를 재할당하여 변경하여도 arguments 객체에 반영되지 않는다.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://parksaneon.github.io/2020/08/27/prototype/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Park facamp">
      <meta itemprop="description" content="All Dev stories">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Park facamp's blog">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/27/prototype/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-08-27 17:13:57 / Modified: 17:16:34" itemprop="dateCreated datePublished" datetime="2020-08-27T17:13:57+09:00">2020-08-27</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Prototype"><a href="#Prototype" class="headerlink" title="Prototype"></a>Prototype</h1><p>객체 지향 언어 :  객체(object)의 집합으로 프로그램을 표현하려는 프로그래밍 언어</p>
<p>자바스크립트는 프로토타입 기반의 객체지향 프로그래밍 언어 이다.</p>
<p><strong>자바스크립트는 객체 기반의 프로그래밍 언어이며 자바스크립트를 이루고 있는 “거의 모든 것”이 객체다.</strong> 원시 타입(primitive type)의 값을 제외한 나머지 값들(함수, 배열, 정규표현식 등)은 모두 객체다.</p>
<p>원시 타입</p>
<ul>
<li>string</li>
<li>number</li>
<li>boolean</li>
<li>null</li>
<li>undefined</li>
<li>symbol</li>
</ul>
<p>객체 타입</p>
<ul>
<li>객체<ul>
<li>배열</li>
<li>함수</li>
<li>정규표현식</li>
</ul>
</li>
</ul>
<p>사람에게는 다양한 속성이 있으나 우리가 구현하려는 프로그램에서는 사람의 “이름”과 “주소”라는 속성에만 관심이 있다고 가정하자. 이처럼 다양한 속성 중에서 프로그램에 필요한 속성만 간추려 내어 표현하는 것을 **추상화(abstraction)**라 한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 이름과 주소 속성을 갖는 객체</span></span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  name: <span class="string">&#x27;Lee&#x27;</span>,</span><br><span class="line">  address: <span class="string">&#x27;Seoul&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>이처럼 객체지향 프로그래밍은 객체의 **상태(state)**를 나타내는 데이터와 상태 데이터를 조작할 수 있는 **동작(behavior)**을 하나의 논리적인 단위로 묶어 생각한다.</p>
<p>객체 : <strong>상태 데이터와 동작을 하나의 논리적인 단위로 묶은 복합적인 자료구조</strong></p>
<p>자바스크립트의 객체에서는 상태 데이터를 프로퍼티(property), 동작을 메서드(method)라 부른다.</p>
<h3 id="상속과-프로토타입"><a href="#상속과-프로토타입" class="headerlink" title="상속과 프로토타입"></a>상속과 프로토타입</h3><p>어떤 객체의 프로퍼티 또는 메서드를 다른 객체가 상속받아 그대로 사용할 수 있는 것을 말한다.</p>
<p>상속을 사용하면 불필요한 중복을 제거할 수 있고, 이는 기존의 코드를 재사용하는 것으로 구현이 가능하다.</p>
<p>생성자 함수를 이용하면 미리 구현 템플릿으로 형태가 같은 객체(인스턴스)를 여러개로 생성이 가능하다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 생성자 함수</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Circle</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.radius = radius;</span><br><span class="line">  <span class="built_in">this</span>.getArea = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Math.PI는 원주율을 나타내는 상수다.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.PI * <span class="built_in">this</span>.radius ** <span class="number">2</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 반지름이 1인 인스턴스 생성</span></span><br><span class="line"><span class="keyword">const</span> circle1 = <span class="keyword">new</span> Circle(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 반지름이 2인 인스턴스 생성</span></span><br><span class="line"><span class="keyword">const</span> circle2 = <span class="keyword">new</span> Circle(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(circle1.getArea === circle2.getArea); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>그런데 위의 예제에서는 getArea라는 함수는 중복적인 내용이다.</p>
<p>중복적인 내용을 각 인스턴스가 소유하는 것보다는 하나만 생성하여 이를 공유하는 것이 메모리상으로 효율적이다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Circle.prototype.getArea = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.PI * <span class="built_in">this</span>.radius ** <span class="number">2</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 인스턴스 생성</span></span><br><span class="line"><span class="keyword">const</span> circle1 = <span class="keyword">new</span> Circle(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> circle2 = <span class="keyword">new</span> Circle(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(circle1.getArea === circle2.getArea); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>모든 생성자 함수는 해당 함수와 짝이 되는 프로토 타입을 가지며, 생성된 객체는 해당 프로토타입의 모든 프로퍼티와 메서드를 상속받는다.</p>
<h3 id="프로토타입"><a href="#프로토타입" class="headerlink" title="프로토타입"></a>프로토타입</h3><p>프로토타입 객체(또는 줄여서 프로토타입)란 객체지향 프로그래밍의 근간을 이루는 객체 간 상속을 구현하기 위해 사용된다. </p>
<p>프로토타입은 어떤 객체의 상위(부모) 객체의 역할을 하는 객체로서 다른 객체에 공유 프로퍼티(메서드 포함)를 제공한다. 프로토타입을 상속받은 하위(자식) 객체는 상위 객체의 프로퍼티를 자신의 프로퍼티처럼 자유롭게 사용할 수 있다.</p>
<p>모든 객체는 하나의 프로토타입을 갖는다.([[Prototype]]) 그리고 모든 프로토타입은 생성자 함수와 연결되어 있다.</p>
<p>객체 리터럴에 의해 생성된 객체의 프로토타입은 Object.prototype이고,</p>
<p>생성자 함수에 의해 생성된 객체의 프로토타입은 생성자 함수의 prototype 프로퍼티에 바인딩되어 있는 객체다. </p>
<p>[[Prototype]] 내부 슬롯에는 직접 접근할 수 없지만, <strong>proto</strong> 접근자 프로퍼티를 통해 자신의 프로토타입, 즉 자신의 [[Prototype]] 내부 슬롯이 가리키는 프로토타입에 간접적으로 접근할 수 있다.</p>
<p>그리고 프로토타입은 자신의 constructor 프로퍼티를 통해 생성자 함수에 접근할 수 있고, 생성자 함수는 자신의 prototype 프로퍼티를 통해 프로토타입에 접근할 수 있다.</p>
<h3 id="proto"><a href="#proto" class="headerlink" title="proto"></a><strong>proto</strong></h3><p><strong>모든 객체는 <strong>proto</strong> 접근자 프로퍼티를 통해 자신의 프로토타입, 즉 [[Prototype]] 내부 슬롯에 간접적으로 접근할 수 있다.</strong> </p>
<p><strong>proto</strong> 접근자 프로퍼티는 상속을 통해 사용된다.</p>
<p><strong>proto</strong> 접근자 프로퍼티는 객체가 직접 소유하는 프로퍼티가 아니라 Object.prototype의 프로퍼티다. 모든 객체는 상속을 통해 Object.prototype.<strong>proto</strong> 접근자 프로퍼티를 사용할 수 있다.</p>
<h4 id="Object-prototype"><a href="#Object-prototype" class="headerlink" title="Object.prototype"></a>Object.prototype</h4><p>모든 객체는 프로토타입의 계층 구조인 프로토타입 체인에 묶여 있다. 자바스크립트 엔진은 객체의 프로퍼티(메서드 포함)에 접근하려고 할 때 해당 객체에 접근하려는 프로퍼티가 없다면 <strong>proto</strong> 접근자 프로퍼티가 가리키는 참조를 따라 자신의 부모 역할을 하는 프로토타입의 프로퍼티를 순차적으로 검색한다. </p>
<p>프로토타입 체인의 종점, 즉 프로토타입 체인의 최상위 객체는 Object.prototype이며, 이 객체의 프로퍼티와 메서드는 모든 객체에게 상속된다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<p>Object.create() 함수를 사용하면 해당 객체의 prototype을 지정할 수 있는데 저렇게 명시적으로 지정을 하면 프로토타입으로부터 상속을 받을 수 없다.</p>
<h3 id="생성자-함수-prototype"><a href="#생성자-함수-prototype" class="headerlink" title="생성자 함수 prototype"></a>생성자 함수 prototype</h3><p>함수 객체만이 소유하는 prototype 프로퍼티는 생성자 함수가 생성할 인스턴스의 프로토타입을 가리킨다.</p>
<p>일반 객체는 프로토 타입을 Object.prototype을 가지며,</p>
<p>생성사 함수에 의함 객체는 프로토 타입을 생성자 함수의 prototype로 가진다.</p>
<p>생정자 함수의 prototype은 프로토 타입으로 Object.prototype을 가진다.</p>
<p>Object.prototype -&gt; 생성자 함수 prototype -&gt; 인스턴스</p>
<p>Object.prototype -&gt; 일반 객체  </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://parksaneon.github.io/2020/08/27/property-attribute/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Park facamp">
      <meta itemprop="description" content="All Dev stories">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Park facamp's blog">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/27/property-attribute/" class="post-title-link" itemprop="url">property attribute</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-08-27 17:13:38 / Modified: 17:16:16" itemprop="dateCreated datePublished" datetime="2020-08-27T17:13:38+09:00">2020-08-27</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="프로퍼티-어트리뷰트"><a href="#프로퍼티-어트리뷰트" class="headerlink" title="프로퍼티 어트리뷰트"></a>프로퍼티 어트리뷰트</h1><h3 id="내부-슬롯-내부-메서드"><a href="#내부-슬롯-내부-메서드" class="headerlink" title="내부 슬롯 / 내부 메서드"></a>내부 슬롯 / 내부 메서드</h3><p>ECMAScript 사양에서 사용하는 의사 프로퍼티(pseudo property)와 의사 메서드(pseudo method)이다. ECMAScript 사양에 등장하는 **이중 대괄호([[…]])**로 감싼 이름들이 내부 슬롯과 내부 메서드다.</p>
<p>내부 슬롯과 내부 메서드는 ECMAScript 사양에 정의된 대로 구현되어 자바스크립트 엔진에서 실제로 동작하지만 개발자가 직접 접근할 수 있도록 외부로 공개된 객체의 프로퍼티는 아니다.</p>
<p>내부 슬롯과 내부 메서드는 <strong>자바스크립트 엔진의 내부 로직</strong>이므로 원칙적으로 자바스크립트는 내부 슬롯과 내부 메서드에 직접적으로 접근하거나 호출할 수 있는 방법을 제공하지 않는다. 단, <strong>일부 내부 슬롯과 내부 메서드에 한하여 간접적으로 접근할 수 있는 수단을 제공</strong>하기는 한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> o = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 내부 슬롯은 자바스크립트 엔진의 내부 로직이므로 직접 접근할 수 없다.</span></span><br><span class="line">o.[[Prototype]] <span class="comment">// -&gt; Uncaught SyntaxError: Unexpected token &#x27;[&#x27;</span></span><br><span class="line"><span class="comment">// 단, 일부 내부 슬롯과 내부 메서드에 한하여 간접적으로 접근할 수 있는 수단을 제공하기는 한다.</span></span><br><span class="line">o.__proto__ <span class="comment">// -&gt; Object.prototype</span></span><br></pre></td></tr></table></figure>



<h3 id="프로퍼티-어트리뷰트-프로퍼티-디스크립터-객체"><a href="#프로퍼티-어트리뷰트-프로퍼티-디스크립터-객체" class="headerlink" title="프로퍼티 어트리뷰트 / 프로퍼티 디스크립터 객체"></a>프로퍼티 어트리뷰트 / 프로퍼티 디스크립터 객체</h3><p><strong>프로퍼티 어트리뷰트(PropertyAttribute)</strong> : 해당 객체의 상태 </p>
<p><strong>프로퍼티 디스크립터(PropertyDescriptor) 객체</strong> : 해당 객체에 대한 설명 정보를 제공하는 객체 ( 프로퍼티 어트리뷰트 정보를 포함한다 )</p>
<p>자바스크립트 엔진은 <strong>프로퍼티를 생성할 때</strong> <strong>프로퍼티의 상태를 나타내는 프로퍼티 어트리뷰트를 기본값으로 자동 정의</strong>한다. </p>
<p>프로퍼티의 상태란 프로퍼티의 값(value), 값의 갱신 가능 여부(writable), 열거 가능 여부(enumerable), 재정의 가능 여부(configurable)를 말한다.</p>
<p> 프로퍼티 어트리뷰트에 직접 접근할 수 없지만 Object.getOwnPropertyDescriptor 메서드를 사용하여 간접적으로 확인할 수는 있다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  name: <span class="string">&#x27;Lee&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 프로퍼티 어트리뷰트 정보를 제공하는 프로퍼티 디스크립터 객체를 반환한다.</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(person, <span class="string">&#x27;name&#x27;</span>));</span><br><span class="line"><span class="comment">// &#123;value: &quot;Lee&quot;, writable: true, enumerable: true, configurable: true&#125;</span></span><br></pre></td></tr></table></figure>

<p>Object.getOwnPropertyDescriptor 메서드는 프로퍼티 어트리뷰트 정보를 제공하는 <strong>프로퍼티 디스크립터(PropertyDescriptor) 객체</strong>를 반환한다.</p>
<p>만약 존재하지 않는 프로퍼티나 상속받은 프로퍼티에 대한 프로퍼티 디스크립터를 요구하면 undefined가 반환된다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  name: <span class="string">&#x27;Lee&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 프로퍼티 동적 생성</span></span><br><span class="line">person.age = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 모든 프로퍼티의 프로퍼티 어트리뷰트 정보를 제공하는 프로퍼티 디스크립터 객체들을 반환한다.</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptors(person));</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  name: &#123;value: &quot;Lee&quot;, writable: true, enumerable: true, configurable: true&#125;,</span></span><br><span class="line"><span class="comment">  age: &#123;value: 20, writable: true, enumerable: true, configurable: true&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>Object.getOwnPropertyDescriptor 메서드는 하나의 프로퍼티에 대해 프로퍼티 디스크립터 객체를 반환하지만 ES8에서 도입된 Object.getOwnPropertyDescriptors 메서드는 모든 프로퍼티의 프로퍼티 어트리뷰트 정보를 제공하는 프로퍼티 디스크립터 객체들을 반환한다.</p>
<h3 id="데이터-프로퍼티-접근자-프로퍼티"><a href="#데이터-프로퍼티-접근자-프로퍼티" class="headerlink" title="데이터 프로퍼티 / 접근자 프로퍼티"></a>데이터 프로퍼티 / 접근자 프로퍼티</h3><p>데이터 프로퍼티(data property) : <strong>키와 값으로 구성</strong>된 일반적인 프로퍼티다. 지금까지 살펴본 모든 프로퍼티는 데이터 프로퍼티다.</p>
<p>접근자 프로퍼티(accessor property) : 자체적으로는 값을 갖지 않고 <strong>다른 데이터 프로퍼티의 값을 읽거나 저장할 때 호출되는 접근자 함수로                                                                  구성된 프로퍼티다.</strong></p>
<h4 id="데이터-프로퍼티"><a href="#데이터-프로퍼티" class="headerlink" title="데이터 프로퍼티"></a>데이터 프로퍼티</h4><p>데이터 프로퍼티(data property)는 다음과 같은 프로퍼티 어트리뷰트를 갖는다. 이 프로퍼티 어트리뷰트는 자바스크립트 엔진이 프로퍼티를 생성할 때 기본값으로 자동 정의된다.</p>
<ul>
<li>[[Value]], : 프로퍼티 키를 통해 프로퍼티 <strong>값</strong>에 접근하면 반환되는 값이다.</li>
<li>[[Writable]] : 프로퍼티 값의 <strong>변경 가능 여부</strong>를 나타내며 불리언 값을 갖는다.</li>
<li>[[Enumerable]] :  프로퍼티의 <strong>열거 가능 여부</strong>를 나타내며 불리언 값을 갖는다.</li>
<li>[[Configurable]]: 프로퍼티의 <strong>재정의 가능 여부</strong>를 나타내며 불리언 값을 갖는다.</li>
</ul>
<p>위의 프로퍼티 어트리뷰트들은  프로퍼티 디스크립터 객체에서 value, writable, enumerable, configurable 프로퍼티로 제공된다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  name: <span class="string">&#x27;Lee&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 프로퍼티 어트리뷰트 정보를 제공하는 프로퍼티 디스크립터 객체를 취득한다.</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(person, <span class="string">&#x27;name&#x27;</span>));</span><br><span class="line"><span class="comment">// &#123;value: &quot;Lee&quot;, writable: true, enumerable: true, configurable: true&#125;</span></span><br></pre></td></tr></table></figure>

<p> 프로퍼티가 생성될 때 [[Value]]의 값은 프로퍼티 값으로 초기화되며 [[Writable]], [[Enumerable]], [[Configurable]]의 값은 true로 초기화된다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 프로퍼티 동적 생성</span></span><br><span class="line">person.age = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptors(person));</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  name: &#123;value: &quot;Lee&quot;, writable: true, enumerable: true, configurable: true&#125;,</span></span><br><span class="line"><span class="comment">  age: &#123;value: 20, writable: true, enumerable: true, configurable: true&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>person 객체에 동적으로 프로퍼티를 추가하면 프로퍼티 디스크립터 객체는 이를 반영한다.</p>
<h4 id="접근자-프로퍼티"><a href="#접근자-프로퍼티" class="headerlink" title="접근자 프로퍼티"></a>접근자 프로퍼티</h4><p>접근자 프로퍼티(accessor property)는 자체적으로는 값을 갖지 않고 다른 데이터 프로퍼티의 값을 읽거나 저장할 때 사용하는 접근자 함수(accessor function)로 구성된 프로퍼티다.</p>
<ul>
<li>[[Get]] : 접근자 프로퍼티를 통해 데이터 프로퍼티의 값을 읽을 때 호출되는 접근자 함수</li>
<li>[[Set]] : 접근자 프로퍼티를 통해 데이터 프로퍼티의 값을 저장할 때 호출되는 접근자 함수</li>
<li>[[Enumerable]] : 데이터 프로퍼티의 [[Enumerable]]과 같다.</li>
<li>[[Configurable]] :  데이터 프로퍼티의 [[Configurable]]과 같다.</li>
</ul>
<p>접근자 함수는 getter/setter 함수라고도 부른다. 접근자 프로퍼티는 getter와 setter 함수를 모두 정의할 수도 있고 하나만 정의할 수도 있다. </p>
<p><strong>프로토타입(prototype)</strong></p>
<p>프로토타입은 어떤 객체의 상위(부모) 객체의 역할을 하는 객체다. 프로토타입은 하위(자식) 객체에게 자신의 프로퍼티와 메서드를 상속한다. 프로토타입 객체의 프로퍼티나 메서드를 상속받은 하위 객체는 자신의 프로퍼티 또는 메서드인 것처럼 자유롭게 사용할 수 있다.<br>프로토타입 체인은 프로토타입이 단방향 링크드 리스트 형태로 연결되어 있는 상속 구조를 말한다. 객체의 프로퍼티나 메서드에 접근하려고 할 때 해당 객체에 접근하려는 프로퍼티 또는 메서드가 없다면 프로토타입 체인을 따라 프로토타입의 프로퍼티나 메서드를 차례대로 검색한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 일반 객체의 __proto__는 접근자 프로퍼티다.</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(<span class="built_in">Object</span>.prototype, <span class="string">&#x27;__proto__&#x27;</span>);</span><br><span class="line"><span class="comment">// &#123;get: ƒ, set: ƒ, enumerable: false, configurable: true&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수 객체의 prototype은 데이터 프로퍼티다.</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;, <span class="string">&#x27;prototype&#x27;</span>);</span><br><span class="line"><span class="comment">// &#123;value: &#123;...&#125;, writable: true, enumerable: false, configurable: false&#125;</span></span><br></pre></td></tr></table></figure>



<h3 id="프로퍼티-정의"><a href="#프로퍼티-정의" class="headerlink" title="프로퍼티 정의"></a>프로퍼티 정의</h3><p>새로운 프로퍼티를 추가하면서 프로퍼티 어트리뷰트를 <strong>명시적으로 정의</strong>하거나, 기존 프로퍼티의 프로퍼티 어트리뷰트를 <strong>재정의</strong>하는 것</p>
<h3 id="객체-변경-금지"><a href="#객체-변경-금지" class="headerlink" title="객체 변경 금지"></a>객체 변경 금지</h3><ul>
<li><p>객체 확장 금지 ( Object.preventExtensions ) </p>
<p>프로퍼티 추가 금지</p>
</li>
<li><p>객체 밀봉 ( Object.seal )</p>
<p>프로퍼티 추가 및 삭제와 프로퍼티 어트리뷰트 재정의 금지 / 프로퍼티 갱신만 가능 -&gt; 읽기와 쓰기만 가능</p>
</li>
<li><p>객체 동결 ( Object.freeze )</p>
<p>프로퍼티 추가 및 삭제와 프로퍼티 어트리뷰트 재정의 금지, 프로퍼티 값 갱신 금지 -&gt; 읽기만 가능</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://parksaneon.github.io/2020/08/26/first-class-object/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Park facamp">
      <meta itemprop="description" content="All Dev stories">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Park facamp's blog">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/26/first-class-object/" class="post-title-link" itemprop="url">first-class-object</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-08-26 20:11:44 / Modified: 20:14:09" itemprop="dateCreated datePublished" datetime="2020-08-26T20:11:44+09:00">2020-08-26</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="일급객체"><a href="#일급객체" class="headerlink" title="일급객체"></a>일급객체</h1><ul>
<li>무명의 리터럴로 생성할 수 있다. 즉, 런타임에 생성이 가능하다.</li>
<li>변수나 자료구조(객체, 배열 등)에 저장할 수 있다.</li>
<li>함수의 매개변수에게 전달할 수 있다.</li>
<li>함수의 반환값으로 사용할 수 있다.</li>
</ul>
<p>위의 조건을 만족하면 일급 객체라 하는데</p>
<p>자바스크립트 함수 객체의 위의 조건을 모두 충족하므로 일극 객체라 할 수 있다.</p>
<p>함수는 객체이나 일반 객체와는 차이가 있다.</p>
<p>일반 객체는 호출할 수 없지만 <strong>함수 객체는 호출</strong>할 수 있다. 그리고 함수 객체는 일반 객체에는 없는 <strong>함수 고유의 프로퍼티</strong>를 소유한다.</p>
<h3 id="arguments-프로퍼티"><a href="#arguments-프로퍼티" class="headerlink" title="arguments 프로퍼티"></a>arguments 프로퍼티</h3><p>함수 객체의 arguments 프로퍼티 값은 arguments 객체다. </p>
<p>arguments 객체는 함수 호출 시 전달된 인수(argument)들의 정보를 담고 있는 순회 가능한 유사 배열 객체이며, 함수 내부에서 지역 변수처럼 사용된다.</p>
<p>함수가 호출되면 함수 몸체 내에서 암묵적으로 매개변수가 선언되고 undefined로 초기화된 이후 인수가 할당된다.</p>
<p>모든 인수는 암묵적으로 arguments 객체의 프로퍼티로 보관된다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// arguments 객체는 length 프로퍼티가 있는 유사 배열 객체이므로 for 문으로 순회할 수 있다.</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">    res += <span class="built_in">arguments</span>[i];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sum());        <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">1</span>, <span class="number">2</span>));    <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>

<p>유사 배열 객체는 배열이 아니므로 배열 메서드를 사용할 경우 에러가 발생한다.</p>
<p>일반 객체처럼 사용하려면</p>
<ul>
<li><p>Function.prototype.call</p>
</li>
<li><p>Function.prototype.apply</p>
</li>
</ul>
<p>등으로 유사 배열객체를 배열로 변환해 줘야 한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br></pre></td></tr></table></figure>



<h2 id="proto-접근자-프로퍼티"><a href="#proto-접근자-프로퍼티" class="headerlink" title="proto 접근자 프로퍼티"></a><strong>proto</strong> 접근자 프로퍼티</h2><p>모든 객체는 [[Prototype]]이라는 내부 슬롯을 갖는다. [[Prototype]] 내부 슬롯은 객체 지향 프로그래밍의 상속을 구현하는 프로토타입 객체를 가리킨다.</p>
<p><strong>proto</strong> 는 [[Prototype]] 내부 슬롯이 가리키는 프로토타입 객체에 접근하기 위해 사용하는 접근자 프로퍼티다.</p>
<h2 id="prototype-프로퍼티"><a href="#prototype-프로퍼티" class="headerlink" title="prototype 프로퍼티"></a>prototype 프로퍼티</h2><p>prototype 프로퍼티는 생성자 함수만이 소유하는 프로퍼티다. 일반 객체와 생성자 함수로 호출할 수 없는 함수에는 prototype 프로퍼티가 없다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 함수 객체는 prototype 프로퍼티를 소유한다.</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;).hasOwnProperty(<span class="string">&#x27;prototype&#x27;</span>); <span class="comment">// -&gt; true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 일반 객체는 prototype 프로퍼티를 소유하지 않는다.</span></span><br><span class="line">(&#123;&#125;).hasOwnProperty(<span class="string">&#x27;prototype&#x27;</span>); <span class="comment">// -&gt; false</span></span><br></pre></td></tr></table></figure>

<p>prototype 프로퍼티는 함수가 객체를 생성하는 생성자 함수로 호출될 때 생성자 함수가 생성할 인스턴스의 프로토타입 객체를 가리킨다.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://parksaneon.github.io/2020/08/26/new-function/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Park facamp">
      <meta itemprop="description" content="All Dev stories">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Park facamp's blog">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/26/new-function/" class="post-title-link" itemprop="url">new function</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-08-26 20:11:34 / Modified: 20:14:00" itemprop="dateCreated datePublished" datetime="2020-08-26T20:11:34+09:00">2020-08-26</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="생성자-함수"><a href="#생성자-함수" class="headerlink" title="생성자 함수"></a>생성자 함수</h1><p>생성자 함수 : new 연산자와 함께 호출하여 객체(인스턴스)를 생성하는 함수</p>
<p>인스턴스 : 생성자 함수에 의해 생성된 객체</p>
<p>객체는 객체 리터럴 {} 외에도 생성하는 방법이 몇가지 존재하는데 생성자 함수도 그중 하나이다.</p>
<h3 id="Object-생성자-함수"><a href="#Object-생성자-함수" class="headerlink" title="Object 생성자 함수"></a>Object 생성자 함수</h3><p>new키워드와 Object 함수를 이용하여 객체를 생성하고 해당 객체에 사용을 원하는 프로퍼티 추가</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 객체 생성</span></span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 프로퍼티 추가</span></span><br><span class="line">person.name = <span class="string">&#x27;Lee&#x27;</span>;</span><br><span class="line">person.sayHello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Hi! My name is &#x27;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>위의 방식 보다는 객체 리터럴{}를 사용해서 생성하는 것이 더 간결해 보인다. </p>
<h3 id="생성자-함수-1"><a href="#생성자-함수-1" class="headerlink" title="생성자 함수"></a>생성자 함수</h3><p>객체 리터럴은 간편하지만, 단 하나의 객체만을 생성한다. 혹시 여러 프로퍼티를 지닌 동일한 형태의 객체를 여러개 생성하는 경우에 객체 리터럴은 그다지 좋은 방법은 아니다.</p>
<p>객체의 각 프로퍼티 값은 달라질 수 있으나 그 안의 메소드는 동작하는 방식이 같으므로 같은 것을 여러개 작성하는 것은 비효율 적이다.</p>
<p>생성자 함수에 의한 객체 생성 방식은 마치 객체(인스턴스)를 생성하기 위한 하나의 템플릿처럼 생성자 함수를 사용하여 프로퍼티 구조가 동일한 객체 여러 개를 간편하게 생성할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 생성자 함수</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Circle</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 생성자 함수 내부의 this는 생성자 함수가 생성할 인스턴스를 가리킨다.</span></span><br><span class="line">  <span class="built_in">this</span>.radius = radius;</span><br><span class="line">  <span class="built_in">this</span>.getDiameter = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * <span class="built_in">this</span>.radius;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 인스턴스의 생성</span></span><br><span class="line"><span class="keyword">const</span> circle1 = <span class="keyword">new</span> Circle(<span class="number">5</span>);  <span class="comment">// 반지름이 5인 Circle 객체를 생성</span></span><br><span class="line"><span class="keyword">const</span> circle2 = <span class="keyword">new</span> Circle(<span class="number">10</span>); <span class="comment">// 반지름이 10인 Circle 객체를 생성</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(circle1.getDiameter()); <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(circle2.getDiameter()); <span class="comment">// 20</span></span><br></pre></td></tr></table></figure>



<h4 id="this"><a href="#this" class="headerlink" title="this"></a>this</h4><p>자바스크립트의 스코프는 정적스코프 ( 렉시컬 스코프 ) - 함수가 정의된 환경에 따라 스코프가 결정됨   </p>
<p>로 스코프를 결정한다.</p>
<p>그러나 this는 해당 키워드를 사용하는 함수를 어떻게 사용하느냐에 따라 가르키는 값이 다르다.</p>
<p>우선 this는 키워드인 객체라고 생각하자</p>
<p>this는 함수 호출 방식에 따라 식별하는 객체가 다른데</p>
<ul>
<li>일반 호출</li>
<li>메소드 내부 호출</li>
<li>인스턴스 호출</li>
</ul>
<p>일반 함수로서 this를 호출하면 window객체를 가르킨다 ( 일부러 이렇게 하는 법은 없으므로 꼭 지양할 것 )</p>
<p>일반 객체 내부에서 this를 호출하면 this는 객체를 가르킨다.</p>
<p>생성자 함수 내부에서 this를 호출하면 this는 해당 생성자 함수가 생성하는 객체를 가르킨다.</p>
<h2 id="생성자-함수-gt-인스턴스"><a href="#생성자-함수-gt-인스턴스" class="headerlink" title="생성자 함수 -&gt; 인스턴스"></a>생성자 함수 -&gt; 인스턴스</h2><p>암묵적으로 빈 객체가 생성된다. 이 빈 객체가 생성자 함수가 생성한 인스턴스다.</p>
<p>그리고 <strong>암묵적으로</strong> <strong>생성된 빈 객체, 즉 인스턴스는 this에 바인딩된다.</strong> 생성자 함수 내부의 this가 생성자 함수가 생성할 인스턴스를 가리키는 이유가 바로 이것이다. 이 처리는 함수 몸체의 코드가 한 줄씩 실행되는 <strong>런타임 이전에 실행된다.</strong></p>
<p>런타임 이전에 빈객체가 만들어지고 this에 이 빈객체가 바인딩된 다음에는</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Circle</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 암묵적으로 인스턴스가 생성되고 this에 바인딩된다.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//this에 바인딩되어 있는 인스턴스를 초기화한다.</span></span><br><span class="line">  <span class="built_in">this</span>.radius = radius;</span><br><span class="line">  <span class="built_in">this</span>.getDiameter = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * <span class="built_in">this</span>.radius;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>위의 처럼 빈 객체의 프로퍼티를 정의한다.</p>
<p>생성자 함수는 암묵적으로 생성된 빈객체가 바인딩된 this가 암묵적으로 반환된다.</p>
<p>만약에 명시적으로 원시값을 반환하면 그 반환은 무시되고 this가 반환된다.</p>
<h3 id="Call-Construct"><a href="#Call-Construct" class="headerlink" title="Call / Construct"></a>Call / Construct</h3><p>함수 선언문 또는 함수 표현식으로 정의한 함수는 일반적인 함수로서 호출할 수 있는 것은 물론 생성자 함수로서 호출할 수 있다. </p>
<p>생성자 함수로서 호출한다는 것은 new 연산자와 함께 호출하여 객체를 생성하는 것을 의미한다.</p>
<p>함수는 객체이므로 일반 객체와 마찬가지로 내부 슬록, 내부 메서드를 가진다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수는 객체이므로 프로퍼티를 소유할 수 있다.</span></span><br><span class="line">foo.prop = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수는 객체이므로 메서드를 소유할 수 있다.</span></span><br><span class="line">foo.method = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.prop);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>일반 객체와 달리 함수는 호출할 수도 있다.</p>
<p>함수 객체는 일반 객체가 가지고 있는 내부 슬롯과 내부 메서드는 물론, 함수로서 동작하기 위해 함수 객체만을 위한 [[[Environment]], [[FormalParameters]] 등의 내부 슬롯과 [[Call]], [[Construct]] 같은 내부 메서드를 추가로 가지고 있다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 일반적인 함수로서 호출: [[Call]]이 호출된다.</span></span><br><span class="line">foo();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 생성자 함수로서 호출: [[Construct]]가 호출된다.</span></span><br><span class="line"><span class="keyword">new</span> foo();</span><br></pre></td></tr></table></figure>

<p>그러나 모든 함수가 생성자 함수로 동작하는 것은 아니다.</p>
<p>es6의 축약 표현으로 구현한 메소드나 화살표 함수는 생성자 함수로 기능하지 못한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 화살표 함수 정의</span></span><br><span class="line"><span class="keyword">const</span> arrow = <span class="function">() =&gt;</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> arrow(); <span class="comment">// TypeError: arrow is not a constructor</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 메서드 정의: ES6의 메서드 축약 표현만을 메서드로 인정한다.</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  x() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> obj.x(); <span class="comment">// TypeError: obj.x is not a constructor</span></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://parksaneon.github.io/2020/08/25/let-const/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Park facamp">
      <meta itemprop="description" content="All Dev stories">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Park facamp's blog">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/25/let-const/" class="post-title-link" itemprop="url">let / const</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-08-25 15:55:47 / Modified: 15:57:41" itemprop="dateCreated datePublished" datetime="2020-08-25T15:55:47+09:00">2020-08-25</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="const-let"><a href="#const-let" class="headerlink" title="const, let"></a>const, let</h1><p>기존의 변수키워드인 var는 몇가지 좋지 않은 점이 있다.</p>
<ol>
<li>변수 중복 선언 허용</li>
</ol>
<p>​    var 키워드로 선언한 변수를 중복 선언하면 기존에 변수에 할당된 값이 덮어 쓰여져 오류가 발생하지 않는다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// var 키워드로 선언된 변수는 같은 스코프 내에서 중복 선언을 허용한다.</span></span><br><span class="line"><span class="comment">// 초기화문이 있는 변수 선언문은 자바스크립트 엔진에 의해 var 키워드가 없는 것처럼 동작한다.</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">100</span>;</span><br><span class="line"><span class="comment">// 초기화문이 없는 변수 선언문은 무시된다.</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(x); <span class="comment">// 100</span></span><br></pre></td></tr></table></figure>



<ol start="2">
<li>함수 레벨 스코프</li>
</ol>
<p>​    var 키워드로 선언한 변수는 오로지 함수의 코드 블록만을 지역 스코프로 인정한다. 따라서 함수 외부에서 var 키워드로 선언한 변수는 코드 블록 내에서 선언해    도 모두 전역 변수가 된다.</p>
<p>​    가령 if나 for문에 선언한 변수는 해당 스코프에서만 사용하길 원하지만 자바스크립트는 이를 전역변수로 취급한다.</p>
<ol start="3">
<li>호이스팅</li>
</ol>
<p>​    호이스팅에 의해 끌어올려진 변수는 undefined를 할당받는다. </p>
<h2 id="es6-변수-키워드"><a href="#es6-변수-키워드" class="headerlink" title="es6 변수 키워드"></a>es6 변수 키워드</h2><p>let과 const는 위에 언급한 단점들이 보완된 변수 키워드 들이다.</p>
<ol>
<li><p>변수 중복 선언 금지</p>
<p>  var 키워드로 선언한 변수는 오로지 함수의 코드 블록만을 지역 스코프로 인정한다. 따라서 함수 외부에서 var 키워드로 선언한 변수는 코드 블록 내에서 선언해    도 모두 전역 변수가 된다. </p>
</li>
</ol>
<p>​    그러나 let 키워드로 이름이 같은 변수를 중복 선언하면 문법 에러(SyntaxError)가 발생한다.</p>
<ol start="2">
<li>블록 레벨 스코프</li>
</ol>
<p>​    var 키워드로 선언한 변수는 오로지 함수의 코드 블록만을 지역 스코프로 인정하는 함수 레벨 스코프를 따른다.</p>
<p>   그러나 let 키워드로 선언한 변수는 모든 <strong>코드 블록(함수, if 문, for 문, while 문, try/catch 문 등)을 지역 스코프로 인정하는 블록 레벨 스코프</strong> 를 따른다. </p>
<ol start="3">
<li>호이스팅 x</li>
</ol>
<p>​    let 키워드로 선언한 변수는 변수 호이스팅이 발생하지 않는 것처럼 동작한다.</p>
<h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p>const 키워드로 선언한 변수는 선언과 동시에 초기화를 해줘야 한다.</p>
<p>const는 let 변수와 달리 <strong>재할당이 금지된다.</strong></p>
<p>변수와 달리 const 키워드는 상수라는 것을 선언하는데, <strong>상수는 재할당이 금지된 변수를 말한다.</strong></p>
<p>const에 선언한 원시값 ( string, number, boolean, null, undefined…) 등은 값 변경이 불가능 하다.</p>
<p>그러나 객체를 할당한 경우에는 값 재할당은 불가능 하지만, 객체 내부의 값을 변경하는 것은 가능하다. 객체 내부의 값 수정은 재할당이 없어도 가능하기 때문이다.</p>
<p>프로퍼티 동적 생성, 삭제, 프로퍼티 값의 변경을 통해 객체를 변경하는 것은 가능하다. </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://parksaneon.github.io/2020/08/25/life-cycle/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Park facamp">
      <meta itemprop="description" content="All Dev stories">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Park facamp's blog">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/25/life-cycle/" class="post-title-link" itemprop="url">life-cycle</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-08-25 15:55:40 / Modified: 15:57:22" itemprop="dateCreated datePublished" datetime="2020-08-25T15:55:40+09:00">2020-08-25</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="변수-생명주기"><a href="#변수-생명주기" class="headerlink" title="변수 생명주기"></a>변수 생명주기</h1><p>변수는 선언에 의해 생성되고 할당에 의해 값을 할당받는다. 그리고 사용이 끝난 변수는 소멸하는데 이를 생명주기라고 한다.</p>
<p>생명주기가 없다면 변수는 종료를 하지 않는 한 메모리 공간을 계속 점유한다.</p>
<p>전역변수는 웹 어플의 생명주기와 같고 지역변수는 해당 함수가 종료시에 같이 소멸한다. 이는 지역 함수는 함수가 호출되어 실행되는 동안만 생명주기가 유효하다는 의미다.</p>
<h3 id="지역-변수"><a href="#지역-변수" class="headerlink" title="지역 변수"></a>지역 변수</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="string">&#x27;global&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x); <span class="comment">// ①</span></span><br><span class="line">  <span class="keyword">var</span> x = <span class="string">&#x27;local&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br><span class="line"><span class="built_in">console</span>.log(x); <span class="comment">// global</span></span><br></pre></td></tr></table></figure>

<p>호이스팅은 전역 환경에서만 일어나는 것이 아니라, 지역(함수) 환경에서도 일어난다. 따라서 위의 foo 함수에서는 x라는 변수가 먼저 호이스팅 되므로 undefined가 출력된다.</p>
<p>호이스팅은 스코프 단위로 일어난다.지역 변수의 호이스팅은 지역 변수의 선언이 지역 스코프의 선두로 끌어 올려진 것처럼 동작한다. 따라서 지역 변수는 함수 전체에서 유효하다. (변수의 선언이 해당 스코프의 선두로 올라간다는 의미) </p>
<h3 id="전역-변수"><a href="#전역-변수" class="headerlink" title="전역 변수"></a>전역 변수</h3><p>지역변수에 비해 전역변수는 생명주기가 길다. 이것은 메모리 소비가 그만큼 높고, 지역 환경에서 전역 변수 검색시 가장 마지막에 검색이 되어 속도상의 차이도 분명이 존재한다.</p>
<p>이를 방지하기 위해서, 전역대신 즉시실행함수를 이용하여 변수를 선언하거나 전역 환경에 객체를 생성하고 그 객체에 전역 변수처럼 사용할 변수들을 저장하는 방법등이 존재한다.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://parksaneon.github.io/2020/08/25/scope/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Park facamp">
      <meta itemprop="description" content="All Dev stories">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Park facamp's blog">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/25/scope/" class="post-title-link" itemprop="url">scope</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-08-25 15:55:32 / Modified: 15:57:07" itemprop="dateCreated datePublished" datetime="2020-08-25T15:55:32+09:00">2020-08-25</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Scope"><a href="#Scope" class="headerlink" title="Scope"></a>Scope</h1><p>함수 내부에서 선언된 변수는 내부에서만 참조가 가능하고 외부에서는 사용이 불가능하다. 반면에 외부에서 선언된 변수는 함수 내부에서도 사용이 가능한데 이것은 함수 내부와 외부에 각각 선언된 변수의 유효범위(스코프)가 다르기 때문이다.</p>
<p> <strong>모든 식별자(변수 이름, 함수 이름, 클래스 이름 등)는 자신이 선언된 위치에 의해 다른 코드가 식별자 자신을 참조할 수 있는 유효 범위가 결정된다. 이를 스코프라 한다. 즉, 스코프는 식별자가 유효한 범위를 말한다.</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="string">&#x27;global&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="string">&#x27;local&#x27;</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(x); <span class="comment">// ①</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(x); <span class="comment">// ②</span></span><br></pre></td></tr></table></figure>

<p>위의 예제를 보면 전역변수 x와 foo함수 내부의 변수x가 존재한다.</p>
<p>자바스크립트 엔진은 스코프를 통해 어떤 변수를 참조할 지 결정하는데 <strong>코드가 어디서 실행되며 주변에 어떤 코드가 있는지</strong>를 의미하는 렉시컬 환경을 고려한다.</p>
<p>우선 전역변수 x는 어디서든 참조가 가능하지만, foo함수 내부변수 x는 foo함수 내에서만 사용이 가능하다.</p>
<p>두 개의 x 변수는 식별자 이름이 동일하지만 자신이 유효한 범위, 즉 스코프가 다른 별개의 변수다.</p>
<p>만약에 스코프라는 개념이 없다면 위의 x는 동일한 변수로 동작하여, 하나는 이름이 같다는 에러가 발생할 것이다.</p>
<p>그래서 스코프(유효 범위)를 통해 식별자인 변수 이름의 충돌을 방지하여 같은 이름의 변수를 사용할 수 있게 한다. 스코프 내에서 식별자는 유일해야 하지만 다른 스코프에는 같은 이름의 식별자를 사용할 수 있다. 즉, 스코프는 네임스페이스(변수 이름을 담은 공간)다.</p>
<h2 id="스코프의-종류"><a href="#스코프의-종류" class="headerlink" title="스코프의 종류"></a>스코프의 종류</h2><ul>
<li><p>전역</p>
<p>코드의 가장 바깥족(외부) 공간이며 존재하며 전역 변수를 가진다.</p>
</li>
<li><p>지역</p>
<p>함수 몸체 내부 공간이며 지역 변수를 가진다.</p>
</li>
</ul>
<p>변수는 자신이 선언된 위치(전역 또는 지역)에 의해 자신이 유효한 범위인 스코프가 결정된다. 즉, 전역에서 선언된 변수는 전역 스코프를 갖는 전역 변수이고, 지역에서 선언된 변수는 지역 스코프를 갖는 지역 변수다.</p>
<h3 id="지역변수"><a href="#지역변수" class="headerlink" title="지역변수"></a>지역변수</h3><p>지역변수는 자신이 선언된 지역과 하위 지역(중첩 함수)에서만 참조할 수 있다. 다시 말해, 지역 변수는 자신의 지역 스코프와 하위 지역 스코프에서 유효하다.</p>
<h2 id="스코프-체인"><a href="#스코프-체인" class="headerlink" title="스코프 체인"></a>스코프 체인</h2><p>변수와 마찬가지로 함수도 전역에서 정의할 수도 있고 함수 몸체 내부에서 정의할 수도 있다. </p>
<p>함수 몸체 내부에서 함수가 정의된 것을 ‘함수의 중첩’이라 한다. 그리고 함수 몸체 내부에서 정의한 함수를 <strong>중첩 함수</strong>, 중첩 함수를 포함하는 함수를 <strong>외부 함수</strong>라고 한다.</p>
<p>모든 스코프는 하나의 계층적 구조로 연결되며, 모든 지역 스코프의 최상위 스코프는 전역 스코프이다. 그리고 가장 내부에 선언된 중첩 함수는 자신의 상위 함수부터 순차적으로 위로 거슬로 올라가 전역 스코프에 도달하는데 이 연결을 스코프 체인 이라고 한다.</p>
<p>변수를 참조할 때 자바스크립트 엔진은 스코프 체인을 통해 변수를 참조하는 코드의 스코프에서 시작하여 상위 스코프 방향으로 이동하며 선언된 변수를 검색한다. 이를 통해 상위 스코프에서 선언한 변수를 하위 스코프에서도 참조할 수 있다.</p>
<p>자바스크립트 엔진은 스코프 체인을 따라 변수를 참조하는 코드의 스코프에서 시작해서 상위 스코프 방향으로 이동하며 선언된 변수를 검색한다. <strong>그러나 절대 하위 스코프로 내려가면 식별자를 검색하는 일은 없다</strong>. </p>
<p>이는 <strong>상위 스코프에서 유효한 변수는 하위 스코프에서 자유롭게 참조할 수 있지만 하위 스코프에서 유효한 변수를 상위 스코프에서 참조할 수 없다</strong>는 것을 의미한다.</p>
<p>스코프는 변수뿐 아니라 함수에도 해당한다. 함수는 정의될 때 자바스크립트는 암묵적으로 함수이름과 동일한 변수를 생성하고 그 변수에 함수가 저장된 메모리 주소를 할당한다. 스코프를 “변수를 검색할 때 사용하는 규칙”이라고 표현하기 보다는 <strong>“식별자를 검색하는 규칙”</strong>이라고 표현하는 편이 좀 더 적합하다.</p>
<h3 id="함수-레벨-스코프"><a href="#함수-레벨-스코프" class="headerlink" title="함수 레벨 스코프"></a>함수 레벨 스코프</h3><p>지역은 함수 몸체 내부를 말하고 지역은 지역 스코프를 만든다고 했다. 이는 <strong>코드 블록이 아닌 함수에 의해서만 지역 스코프가 생성된다</strong>는 의미이다.</p>
<p>다른 프로그래밍 언어는 모든 코드블록(if, for, catch, while)등에서 지역 스코프(<strong>블록 레벨 스코프</strong>)를 만들지만 자바스크립트의 var 키워드 변수는 오직 함수의 코드블록만을 지역 스코프로 인정한다. 이래서 <strong>함수 레벨 스코프</strong>라고 부른다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for 문에서 선언한 i는 전역 변수다. 이미 선언된 전역 변수 i가 있으므로 중복 선언된다.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i); <span class="comment">// 0 1 2 3 4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 의도치 않게 변수의 값이 변경되었다.</span></span><br><span class="line"><span class="built_in">console</span>.log(i); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<p>위의 사례처럼 i 변수는 for문에서만 사용하려고 만들어 졌지만, 기존 전역 변수 i와 변수명이 같아 이를 덮어쓴다.</p>
<p>var 함수는 오직 함수 레벨 스코프만을 지역 스코프로 인정해서 이러한 현상이 생긴다.</p>
<h3 id="렉시컬-스코프"><a href="#렉시컬-스코프" class="headerlink" title="렉시컬 스코프"></a>렉시컬 스코프</h3><p><strong>함수를 어디서 정의했는지</strong>에 따라 함수의 상위 스코프를 결정한다.</p>
<p>위의 방식을 렉시컬 스코프 또는 정적 스코프라 한다. 함수의 정의가 평가되는 시점에 상위 스코프가 정적으로 결정되기 때문에 정적 스코프라고 부른다. 자바스크립트를 비롯한 대부분의 프로그래밍 언어는 렉시컬 스코프를 따른다.</p>
<p>자바스크립트는 렉시컬 스코프를 따르므로 함수를 어디서 호출했는지가 아니라 <strong>함수를 어디서 정의했는지</strong>에 따라 상위 스코프를 결정한다. 함수가 호출된 위치는 상위 스코프 결정에 어떠한 영향도 주지 않는다. 즉, 함수의 상위 스코프는 언제나 자신이 정의된 스코프다.</p>
<p>이처럼 함수의 상위 스코프는 함수 정의가 실행될 때 정적으로 결정된다. 함수 정의(함수 선언문 또는 함수 표현식)가 실행되어 생성된 함수 객체는 이렇게 결정된 상위 스코프를 기억한다. 함수가 호출될 때마다 함수의 상위 스코프를 참조할 필요가 있기 때문이다.</p>
<p>*동적 스코프 : <strong>함수를 어디서 호출</strong>했는지에 따라 함수의 상위 스코프를 결정한다  </p>
<p>  -&gt; 자바스크립트는 정적 스코프 방식을 따르므로 동적 스코프 방식으로 생각하지 말것 </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://parksaneon.github.io/2020/08/24/JS-function/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Park facamp">
      <meta itemprop="description" content="All Dev stories">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Park facamp's blog">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/24/JS-function/" class="post-title-link" itemprop="url">JS function</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-08-24 20:11:13 / Modified: 20:11:49" itemprop="dateCreated datePublished" datetime="2020-08-24T20:11:13+09:00">2020-08-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="함수"><a href="#함수" class="headerlink" title="함수"></a>함수</h1><p>자바스크립트의 핵심 개념인 스코프, 실행 컨텍스트, 클로저, 생성자 함수에 의한 객체 생성, 메서드, this, 프로토타입, 모듈화 등이 모두 함수와 깊은 관련이 있다. </p>
<p>수학에서의 함수는 입력(input) 받은 것을 출력(output)한다는 의미</p>
<p>프로그래밍 에서의 <strong>함수는 일련의 과정을 문으로 구현한 다음 이를 코드블럭으로 감싼 하나의 실행 단위</strong>이다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// f(x, y) = x + y</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// f(2, 5) = 7</span></span><br><span class="line">add(<span class="number">2</span>, <span class="number">5</span>); <span class="comment">// 7</span></span><br></pre></td></tr></table></figure>

<p>자바스크립트에서 함수는 객체로서 하나의 값으로 취급된다.</p>
<p><img src="https://poiemaweb.com/assets/fs-images/12-2.png" alt="img"></p>
<p>함수 이름은 하나의 식별자로서 메모리에 저장된 함수를 가르키는 역활을 한다.</p>
<p>함수는 정의를 통해 만들어지지만 실행을 하려면 호출을 따로 해줘야 한다.</p>
<h3 id="사용-이유"><a href="#사용-이유" class="headerlink" title="사용 이유"></a>사용 이유</h3><ol>
<li><p>필요할 때 언제든지 실행할 수 있다. </p>
<p>동일한 작업을 반복적으로 사용할 때 사용되며 이를 코드의 재사용성이라 한다. -&gt;  사용자가 작성한 코드가 동일하게 사용될 때 함수의 사용을 고려할 수 있다.</p>
</li>
<li><p>함수는 변수처럼 이름을 가질 수 있다.</p>
<p>함수는 여러개의 문을 블록으로 감싼 하나의 실행단위라고 볼 수 있는데, 그 실행의 단위에 대한 이름을 지정하여, 해당 함수가 어떤 일을 하는 지를 쉽게 판별할수 있게 하는데 이를 코드의 가독성이라 한다.</p>
</li>
</ol>
<h3 id="함수-리터럴"><a href="#함수-리터럴" class="headerlink" title="함수 리터럴"></a>함수 리터럴</h3><p>리터럴 : 함수를 생성하는 표기법</p>
<p>자바스크립트의 함수는 객체타입의 값이다.  숫자값을 숫자 리터럴로 생성하는 것처럼 함수도 해당 리터럴로 생성할 수 있다. 함수 리터럴은 function키워드, 함수이름, 매개변수 목록, 함수 몸체 등 4가지로 나타낸다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 변수에 함수 리터럴을 할당</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>함수 이름은 식별자로서 네이밍 규칙을 준수해야 하는데 경우에 따라 생략할 수 있다.</p>
<p>이름의 유무에 따라 기명함수(named function) / 익명함수(anonymous function) 라 불린다.</p>
<p>리터럴이 실행되는 시점에 함수라는 하나의 객체를 생성한다. 함수자체가 값(객체)이므로 변수에 할당이 가능하다.</p>
<p>위에 f라는 변수에는 함수가 저장된 메모리의 주소를 참조값으로 가진다.</p>
<p>함수는 객체이지만 일반적인 객체와는 다르다. 일반객체와 달리 함수는 호출이 가능하고, </p>
<h3 id="함수-정의"><a href="#함수-정의" class="headerlink" title="함수 정의"></a>함수 정의</h3><p>함수를 정의하는 방법은 4가지가 존재한다.</p>
<ol>
<li>함수 선언 : 함수 리터럴을 어디에도 할당하지 않고 정의만 내림</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol start="2">
<li>함수 표현식 : 함수 리터럴을 변수에 할당</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<ol start="3">
<li>Fuction 생성자 함수</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> add = <span class="keyword">new</span> Fuction()</span><br></pre></td></tr></table></figure>



<ol start="4">
<li>화살표 함수</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> add = <span class="function">(<span class="params">x, y</span>) =&gt;</span> x + y;</span><br></pre></td></tr></table></figure>



<h3 id="함수-선언문"><a href="#함수-선언문" class="headerlink" title="함수 선언문"></a>함수 선언문</h3><p>함수 리터럴을 이용해 함수를 정의하고, 따로 변수에 함수를 할당하지 않는다. ( 함수 이름 생략 불가능 )</p>
<p>함수 선언문은 표현식이 아닌 문이다.( 값으로 평가될 수 없다 )</p>
<p>그런데 함수 선언문은 변수에 할당해도 정상적으로 동작하는 것으로 보여진다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수 호출</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">2</span>, <span class="number">5</span>)); <span class="comment">// 7</span></span><br></pre></td></tr></table></figure>

<p>자바스크립트 엔진은 함수 선언문이 변수에 할당되지 않으면 함수 선언문으로 해석한다.</p>
<p>반면에 변수에 할당하면, 함수 선언문에 이름이 존재해도 함수 선언문이 아닌, 함수 표현식으로 해석한다.</p>
<p>원래 함수 식별자는 함수 코드블럭 내부에서만 참조가 가능하다. 그런데 외부에서도 함수 식별자를 통한 선언이 가능한 이유는 함수 선언문을 실행할 때, 암묵적으로 선언문의 함수 이름과 동일한 이름의 변수를 생성하고 해당 변수에 생성된 함수 객체를 할당하기 때문이다.</p>
<p>결론적으로 함수를 실행할 때는 해당 함수 명이 아니라 해당 함수가 할당된 함수명과 동일한 변수를 통해 실행하는 것이다.</p>
<p>-&gt; <strong>함수는 함수 이름이 아니라 함수 객체를 가르키는 식별자로 호출한다</strong></p>
<p><img src="https://poiemaweb.com/assets/fs-images/12-7.png" alt="img"></p>
<h3 id="함수-표현식"><a href="#함수-표현식" class="headerlink" title="함수 표현식"></a>함수 표현식</h3><p>함수 리터럴로 생성한 함수를 변수에 할당한다. </p>
<p>함수 리터럴에서 함수 이름은 생략이 가능하다. (함수 선언문은 함수이름과 동일한 변수를 암묵적으로 생성해야 하기때문에 생략이 불가)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 함수 표현식</span></span><br><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>함수는 일급객체로서 값처럼 자유롭게 사용이 가능하다. ( 변수에 할당하는 것도 가능 ) </p>
<p>함수이름은 해당 함수 코드블럭내에서만 참조가 가능하다.</p>
<p>엔진의 암묵적인 동일 변수생성이 없다면 외부에서 실행이 불가능하다. </p>
<h3 id="함수-생성-시점과-함수-호이스팅"><a href="#함수-생성-시점과-함수-호이스팅" class="headerlink" title="함수 생성 시점과 함수 호이스팅"></a>함수 생성 시점과 함수 호이스팅</h3><p>함수 선언문은 선언문 이전에 함수를 실행하면 함수 호이스팅에 의해 정상적으로 동작하지만, 함수 표현식은 이전에 실행시 변수 호이스팅이 일어나 동작하지 않는다.</p>
<p>함수 선언문은 자바스크립트 런타임(위에서 아래로 순차적 실행)이 아닌 런타임이전에 먼저 선언문을 실행한다. ( 변수 선언문도 마찬가지 )</p>
<p>즉 함수 선언문은 런타임 이전에 실행되어 함수 객체가 미리 생성된다. 반면 함수 표현식은 런타임에 의해 해당 줄이 실행될 때 변수에 할당된다.</p>
<h3 id="Fuction-생성자-함수"><a href="#Fuction-생성자-함수" class="headerlink" title="Fuction 생성자 함수"></a>Fuction 생성자 함수</h3><p>생성자 함수란 객체를 생성하는 함수를 말한다.</p>
<p>함수또한 객체이므로 생성자 함수를 통해서 생성된다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> add = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;return x + y&#x27;</span>); <span class="comment">// 매개변수1, 매개변수2, 함수 몸체</span></span><br></pre></td></tr></table></figure>

<p>일반적으로 권장되는 방법은 아니다.</p>
<h3 id="화살표-함수"><a href="#화살표-함수" class="headerlink" title="화살표 함수"></a>화살표 함수</h3><p>function이라는 키워드 대신 화살표 =&gt; 를 사용해 함수를 선언한다. 화살표 함수는 항상 익명함수로 정의한다.</p>
<h2 id="함수호출"><a href="#함수호출" class="headerlink" title="함수호출"></a>함수호출</h2><p>함수 객체를 가르키는 식별자와 한 쌍의 소괄호인 함수 호출 연산자로 실행한다. 소괄호 안에는 0개 이상의 매개변수가 들어간다. 함수가 호출되면 기존 실행 흐름을 중단하고 호출된 함수로 컨트롤이 옮겨진다.</p>
<p>매개변수는 순서대로 할당된다.</p>
<p><img src="https://poiemaweb.com/assets/fs-images/12-9.png" alt="img">함수외부에서 내부로 필요한 값을 전달할 경우는 매개변수를 통해 인수를 전달한다.</p>
<p>인수는 값이어야 하고 타입에는 제한이 없다.</p>
<p>일반적으로 변수는 변수 키워드와 같이 선언하고 런타임 이전에 실행되지만, 매개변수는 함수가 호출된 직후에 실행된다. 이때 초기에는 undefined로 초기화 되었다가 인수 전달을 통해 해당 값을 할당받는다.</p>
<p>자바스크립트는 매개변수와 인수의 수를 체크하지 않는다. 정의된 매개변수보다 인수의 수가 작을 경우엔 나머지 매개변수는 undefined로 유지되며, 더 큰 경우에는 무시되고 그 값들은 arguments 객체에 보관된다.</p>
<p>매개변수는 가능하면 최대 3개 이상을 넘지 않도록 하며, 불가피하게 인수를 많이 전달해야 하는 경우에는 객체나 배열을 이용하여 많은 값을 한 인수에 포함하도록 한다.</p>
<h3 id="반환문"><a href="#반환문" class="headerlink" title="반환문"></a>반환문</h3><p>함수는 반환 키워드 return과 반환값으로 이뤄진 반환문을 통해 실행 결과를 함수 외부로 반환한다.</p>
<p>return 키워드는 함수 외부로 값을 반환하는 것 외에도 함수 실행을 종료하는 기능도 가진다. 반환문 이후에 등장하는 문들은 아무 의미가 없는 문이다. </p>
<p>return을 생략하거나 반환값을 지정하지 않으면 암묵적으로 undefined를 반환한다.</p>
<h3 id="즉시-실행함수"><a href="#즉시-실행함수" class="headerlink" title="즉시 실행함수"></a>즉시 실행함수</h3><p>함수의 정의와 동시에 즉시 호출되는 함수로서 단 한번만 호출되고, 다시 호출할수 없다. 다시 호출이 불가능하므로 함수 이름 생략이 가능하여 익명함수로 사용한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure>

<p>즉시 실행 함수는 반드시 그룹 연사자 () 감싸 줘야 줘야 한다.</p>
<p>그룹 연산자 내부의 함수 리터럴은 함수 표현식으로 동작한다 ( 선언문 x )</p>
<p>그룹 연산자 내부의 함수 표현식은 함수 리터럴로 평가되어 객체가 된다. 객체가 생성됨과 동시에 () 키워드로 함수가 실행된다.  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">!<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line">+<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure>

<p>함수 호출 키워드 소괄호()는 그룹연산자의 외부/내부 어느곳에 위치해도 정상동작 한다.</p>
<p>인수를 전달할 때는 함수 호출 키워드 소괄호() 내부에 작성하면 된다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 즉시 실행 함수에도 일반 함수처럼 인수를 전달할 수 있다.</span></span><br><span class="line">res = (<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;(<span class="number">3</span>, <span class="number">5</span>));</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// 15</span></span><br></pre></td></tr></table></figure>



<h3 id="재귀함수"><a href="#재귀함수" class="headerlink" title="재귀함수"></a>재귀함수</h3><p>함수는 자기 자신을 호출할 수 있는데 이를 재귀함수라고 부른다.</p>
<p>자기 자신을 호출하는 행위이며 재귀 호출을 통해 반복 연산을 구현할 수 있다.</p>
<p>재귀함수는 그냥 사용하면 무한하게 자신을 호출하므로 어느시점에서는 자기 호출을 중단하도록 탈출 조건을 걸어줘야 한다. ( stack overflow 오류 발생 방지 )</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



      

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Park facamp</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

      








    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.0/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  















  

  

</body>
</html>
