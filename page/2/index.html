<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14.0/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"parksaneon.github.io","root":"/","scheme":"Muse","version":"8.0.0-rc.5","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false};
  </script>

  <meta name="description" content="All Dev stories">
<meta property="og:type" content="website">
<meta property="og:title" content="Park facamp&#39;s blog">
<meta property="og:url" content="http://parksaneon.github.io/page/2/index.html">
<meta property="og:site_name" content="Park facamp&#39;s blog">
<meta property="og:description" content="All Dev stories">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Park facamp">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://parksaneon.github.io/page/2/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Park facamp's blog</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Park facamp's blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Park facamp</p>
  <div class="site-description" itemprop="description">All Dev stories</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">25</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



      </section>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">
      

      
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://parksaneon.github.io/2020/08/27/built-in-object/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Park facamp">
      <meta itemprop="description" content="All Dev stories">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Park facamp's blog">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/27/built-in-object/" class="post-title-link" itemprop="url">built in object</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-08-27 17:14:34 / Modified: 17:17:34" itemprop="dateCreated datePublished" datetime="2020-08-27T17:14:34+09:00">2020-08-27</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Built-in-Object-빌트-인-객체"><a href="#Built-in-Object-빌트-인-객체" class="headerlink" title="Built in Object ( 빌트 인 객체 )"></a>Built in Object ( 빌트 인 객체 )</h1><p>JS 객체의 정류 </p>
<ol>
<li>표준 빌트인 객체  : ECMAScript 사양에 정의된 객체로서, 애플리케이션 전역의 공통 기능을 제공</li>
</ol>
<p>​    빌트인 객체는 ECMAScript 사양에 정의된 객체이므로 자바스크립트 실행 환경(브라우저 또는 Node.js 환경)과 관계없이 언제나 사용할 수 있다. 표준 빌트인 객    체는 전역 객체의 프로퍼티로서 제공된다. 따라서 별도의 선언 없이 전역 변수처럼 언제나 참조할 수 있다.</p>
<ol start="2">
<li><p>호스트 객체 : ECMAScript 사양에 정의되어 있지 않지만 <strong>자바스크립트 실행 환경(브라우저 환경 또는 Node.js 환경 등에서 에서 추가로 제공하는 객체</strong>     </p>
</li>
<li><p>사용자 정의 객체 : <strong>사용자가 직접 정의</strong>한 객체</p>
</li>
</ol>
<h3 id="표준-빌트인-객체"><a href="#표준-빌트인-객체" class="headerlink" title="표준 빌트인 객체"></a>표준 빌트인 객체</h3><p>자바스크립트는 Object, String, Number, Boolean, Symbol, Date, Math, RegExp, Array, Map/Set, WeakMap/WeakSet, Function, Promise, Reflect, Proxy, JSON, Error 등의 빌트인 객체를 제공한다.</p>
<p>Math, Reflect, JSON을 제외한 표준 빌트인 객체는 모두 인스턴스를 생성할 수 있는 생성자 함수 객체다. 생성자 함수 객체인 표준 빌트인 객체는 프로토타입 메서드와 정적 메소드를 제공하고 생성자 함수 객체가 아닌 표준 빌트인 객체는 정적 메소드만 제공한다.</p>
<p>예를 들어, 표준 빌트인 객체인 String, Number, Boolean, Function, Array, Date는 생성자 함수로 호출하여 인스턴스를 생성할 수 있다.</p>
<p>생성자 함수인 표준 빌트인 객체가 생성한 인스턴스의 프로토타입은 표준 빌트인 객체의 prototype 프로퍼티에 바인딩된 객체이다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// String 생성자 함수에 의한 String 객체 생성</span></span><br><span class="line"><span class="keyword">const</span> strObj = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&#x27;Lee&#x27;</span>); <span class="comment">// String &#123;&quot;Lee&quot;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// String 생성자 함수를 통해 생성한 strObj 객체의 프로토타입은 String.prototype이다.</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(strObj) === <span class="built_in">String</span>.prototype); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>



<h3 id="원시값-래퍼-객체"><a href="#원시값-래퍼-객체" class="headerlink" title="원시값 / 래퍼 객체"></a>원시값 / 래퍼 객체</h3><p>문자열이나 숫자, 불리언 등의 원시값이 있는데도 문자열, 숫자, 불리언 객체를 생성하는 String, Number, Boolean 등의 표준 빌트인 생성자 함수가 존재한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 원시 타입인 문자열이 프로퍼티와 메서드를 갖고 있는 객체처럼 동작한다.</span></span><br><span class="line"><span class="built_in">console</span>.log(str.length); <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(str.toUpperCase()); <span class="comment">// HELLO</span></span><br></pre></td></tr></table></figure>

<p>위의 예시에서 원시값은 객체가 아니므로 프로퍼티나 메서드를 가질 수 없는데도 원시값인 문자열이 마치 객체처럼 동작한다.</p>
<p>원시값인 문자열, 숫자, 불리언 값의 경우 이들 원시값에 대해 마치 객체처럼 마침표 표기법(또는 대괄호 표기법)으로 접근하면, <strong>자바스크립트 엔진이 일시적으로 원시값을 연관된 객체로 변환</strong>해 주기 때문이다.</p>
<p>원시값을 객체처럼 사용하면 <strong>자바스크립트 엔진은 암묵적으로 연관된 객체를 생성하여 생성된 객체로 프로퍼티에 접근하거나 메서드를 호출하고 다시 원시값으로 되돌린다.</strong></p>
<p>문자열, 숫자, 불리언 값등 <strong>원시값에 대해 객체처럼 접근하면 생성되는</strong> <strong>임시 객체를 래퍼 객체</strong>라고 한다.</p>
<p>원시값에 마침표 표기법 사용 -&gt; 일시적으로 해당 원시값에 연관된 객체로 변호나 -&gt; 연관 객체로 프로퍼티/ 메소드에 접근 호출하고 다시 원시값으로 되돌림</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&#x27;hi&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 원시 타입인 문자열이 래퍼 객체인 String 인스턴스로 변환된다.</span></span><br><span class="line"><span class="built_in">console</span>.log(str.length); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(str.toUpperCase()); <span class="comment">// HI</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 래퍼 객체로 프로퍼티에 접근하거나 메서드를 호출한 후, 다시 원시값으로 되돌린다.</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> str); <span class="comment">// string</span></span><br></pre></td></tr></table></figure>

<p>문자열 래퍼 객체인 String 생성자 함수의 인스턴스는 String.prototype의 메서드를 상속받아 사용할 수 있다.</p>
<p>래퍼 객체의 처리가 종료되면 래퍼 객체의 [[StringData]] 내부 슬롯에 할당된 원시값으로 원래의 상태, 즉 식별자가 원시값을 갖도록 되돌리고 래퍼 객체는 가비지 컬렉션의 대상이 된다. </p>
<p>이는 숫자 타입 값이나 불리언 타입 값도 마찬가지다.</p>
<p>그리고 <strong>문자열, 숫자, 불리언, 심벌</strong> 이외의 원시값, 즉 null과 undefined는 래퍼 객체를 생성하지 않는다. 따라서 null과 undefined 값을 객체처럼 사용하면 에러가 발생한다.</p>
<h3 id="전역객체"><a href="#전역객체" class="headerlink" title="전역객체"></a>전역객체</h3><p>코드가 실행되기 이전 단계에 자바스크립트 엔진에 의해 어떤 객체보다도 먼저 생성되는 특수한 객체이며, 어떤 객체에도 속하지 않은 최상위 객체다.</p>
<p>브라우저 환경에서는 window(또는 self, this, frames)가 전역 객체를 가리키지만 Node.js 환경에서는 global이 전역 객체를 가리킨다.</p>
<p>전역 객체는 표준 빌트인 객체(Object, String, Number, Function, Array 등)와 환경에 따른 호스트 객체(클라이언트 web API 또는 Node.js의 호스트 API), 그리고 <strong>var 키워드로 선언한 전역 변수와 전역 함수를 프로퍼티로 갖는다.</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// var 키워드로 선언한 전역 변수</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.foo); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 선언하지 않은 변수에 값을 암묵적 전역. bar는 전역 변수가 아니라 전역 객체의 프로퍼티다.</span></span><br><span class="line">bar = <span class="number">2</span>; <span class="comment">// window.bar = 2</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.bar); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 전역 함수</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">3</span>; &#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.baz()); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>var키워드 외에 let이나 const 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 아니다.</p>
<p>전역객체는 다음과 같은 특징을 가진다.</p>
<ul>
<li><p>전역 객체는 개발자가 의도적으로 생성할 수 없다. 즉, 전역 객체를 생성할 수 있는 생성자 함수가 제공되지 않는다.</p>
</li>
<li><p>전역 객체의 프로퍼티를 참조할 때 window(또는 global)를 생략할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 전역 프로퍼티는 window를 생략하고 참조할 수 있다.</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.Infinity === <span class="literal">Infinity</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://parksaneon.github.io/2020/08/27/strict-mod/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Park facamp">
      <meta itemprop="description" content="All Dev stories">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Park facamp's blog">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/27/strict-mod/" class="post-title-link" itemprop="url">strict mod</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-08-27 17:14:11 / Modified: 17:17:05" itemprop="dateCreated datePublished" datetime="2020-08-27T17:14:11+09:00">2020-08-27</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="strict-mod"><a href="#strict-mod" class="headerlink" title="strict mod"></a>strict mod</h1><p>자바스크립트는 사용자가 실수로 작성한 코드를 암묵적으로 변환하여 오류의 발생을 줄인다. 얼핏보면 장점으로 보이나 장기적인 관점에서 봤을 때 의도치 않은 에러가 발생할 수 있다.</p>
<p>이를 방지하기 위해 strict mod를 사용한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 즉시 실행 함수의 선두에 strict mode 적용</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  &#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Do something...</span></span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure>

<p>혹 외부 라이브러리를 사용한다면 저역 환경에 strict mod를 사용하다간 충돌이 발생할 수 있으므로 즉시 실행함수 (function(){}()) 내부에 사용하는 것이 좋다.</p>
<h2 id="strict-를-사용한-후-변화"><a href="#strict-를-사용한-후-변화" class="headerlink" title="strict 를 사용한 후 변화"></a>strict 를 사용한 후 변화</h2><ol>
<li>선언하지 않은 변수를 참조하면 에러가 발생한다.</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  &#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  x = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(x); <span class="comment">// ReferenceError: x is not defined</span></span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure>

<p>원래 자바스크립트 엔진은 위의 상황에서 암묵적으로 전역 객체에 x 프로퍼티를 동적 생성한다.</p>
<p>strict 모드를 사용함으로서 선언하지 않은 변수 1이란 값을 할당한 상황에서 정의되지 않은 변수라고 에러를 발생시킨다.</p>
<ol start="2">
<li>delete 연산자</li>
</ol>
<p>delete 연산자로 변수, 함수, 매개변수를 삭제하면 SyntaxError가 발생한다.</p>
<ol start="3">
<li>매개변수 이름의 중복</li>
</ol>
<p>중복된 매개변수 이름을 사용하면 SyntaxError가 발생한다.</p>
<ol start="4">
<li>일반 함수의 this</li>
</ol>
<p>strict mode 에서 함수를 일반 함수로서 호출하면 this에 undefined가 바인딩된다. </p>
<p>원래 대로라면 window라는 전역 객체를 바인딩 한다.</p>
<ol start="5">
<li>arguments 객체</li>
</ol>
<p>매개변수에 전달된 인수를 재할당하여 변경하여도 arguments 객체에 반영되지 않는다.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://parksaneon.github.io/2020/08/27/prototype/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Park facamp">
      <meta itemprop="description" content="All Dev stories">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Park facamp's blog">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/27/prototype/" class="post-title-link" itemprop="url">prototype</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-08-27 17:12:11" itemprop="dateCreated datePublished" datetime="2020-08-27T17:12:11+09:00">2020-08-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-08-28 17:34:22" itemprop="dateModified" datetime="2020-08-28T17:34:22+09:00">2020-08-28</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Prototype"><a href="#Prototype" class="headerlink" title="Prototype"></a>Prototype</h1><p>객체 지향 언어 :  객체(object)의 집합으로 프로그램을 표현하려는 프로그래밍 언어</p>
<p>자바스크립트는 프로토타입 기반의 객체지향 프로그래밍 언어 이다.</p>
<p><strong>자바스크립트는 객체 기반의 프로그래밍 언어이며 자바스크립트를 이루고 있는 “거의 모든 것”이 객체다.</strong> 원시 타입(primitive type)의 값을 제외한 나머지 값들(함수, 배열, 정규표현식 등)은 모두 객체다.</p>
<p>원시 타입</p>
<ul>
<li>string</li>
<li>number</li>
<li>boolean</li>
<li>null</li>
<li>undefined</li>
<li>symbol</li>
</ul>
<p>객체 타입</p>
<ul>
<li>객체<ul>
<li>배열</li>
<li>함수</li>
<li>정규표현식</li>
</ul>
</li>
</ul>
<p>사람에게는 다양한 속성이 있으나 우리가 구현하려는 프로그램에서는 사람의 “이름”과 “주소”라는 속성에만 관심이 있다고 가정하자. 이처럼 다양한 속성 중에서 프로그램에 필요한 속성만 간추려 내어 표현하는 것을 **추상화(abstraction)**라 한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 이름과 주소 속성을 갖는 객체</span></span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  name: <span class="string">&#x27;Lee&#x27;</span>,</span><br><span class="line">  address: <span class="string">&#x27;Seoul&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>이처럼 객체지향 프로그래밍은 객체의 **상태(state)**를 나타내는 데이터와 상태 데이터를 조작할 수 있는 **동작(behavior)**을 하나의 논리적인 단위로 묶어 생각한다.</p>
<p>객체 : <strong>상태 데이터와 동작을 하나의 논리적인 단위로 묶은 복합적인 자료구조</strong></p>
<p>자바스크립트의 객체에서는 상태 데이터를 프로퍼티(property), 동작을 메서드(method)라 부른다.</p>
<h3 id="상속과-프로토타입"><a href="#상속과-프로토타입" class="headerlink" title="상속과 프로토타입"></a>상속과 프로토타입</h3><p>어떤 객체의 프로퍼티 또는 메서드를 다른 객체가 상속받아 그대로 사용할 수 있는 것을 말한다.</p>
<p>상속을 사용하면 불필요한 중복을 제거할 수 있고, 이는 기존의 코드를 재사용하는 것으로 구현이 가능하다.</p>
<p>생성자 함수를 이용하면 미리 구현 템플릿으로 형태가 같은 객체(인스턴스)를 여러개로 생성이 가능하다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 생성자 함수</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Circle</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.radius = radius;</span><br><span class="line">  <span class="built_in">this</span>.getArea = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Math.PI는 원주율을 나타내는 상수다.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.PI * <span class="built_in">this</span>.radius ** <span class="number">2</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 반지름이 1인 인스턴스 생성</span></span><br><span class="line"><span class="keyword">const</span> circle1 = <span class="keyword">new</span> Circle(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 반지름이 2인 인스턴스 생성</span></span><br><span class="line"><span class="keyword">const</span> circle2 = <span class="keyword">new</span> Circle(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(circle1.getArea === circle2.getArea); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>그런데 위의 예제에서는 getArea라는 함수는 중복적인 내용이다.</p>
<p>중복적인 내용을 각 인스턴스가 소유하는 것보다는 하나만 생성하여 이를 공유하는 것이 메모리상으로 효율적이다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Circle.prototype.getArea = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.PI * <span class="built_in">this</span>.radius ** <span class="number">2</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 인스턴스 생성</span></span><br><span class="line"><span class="keyword">const</span> circle1 = <span class="keyword">new</span> Circle(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> circle2 = <span class="keyword">new</span> Circle(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(circle1.getArea === circle2.getArea); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>모든 생성자 함수는 해당 함수와 짝이 되는 프로토 타입을 가지며, 생성된 객체는 해당 프로토타입의 모든 프로퍼티와 메서드를 상속받는다.</p>
<h3 id="프로토타입"><a href="#프로토타입" class="headerlink" title="프로토타입"></a>프로토타입</h3><p>프로토타입 객체(또는 줄여서 프로토타입)란 객체지향 프로그래밍의 근간을 이루는 객체 간 상속을 구현하기 위해 사용된다. </p>
<p>프로토타입은 어떤 객체의 상위(부모) 객체의 역할을 하는 객체로서 다른 객체에 공유 프로퍼티(메서드 포함)를 제공한다. 프로토타입을 상속받은 하위(자식) 객체는 상위 객체의 프로퍼티를 자신의 프로퍼티처럼 자유롭게 사용할 수 있다.</p>
<p>모든 객체는 하나의 프로토타입을 갖는다.([[Prototype]]) 그리고 모든 프로토타입은 생성자 함수와 연결되어 있다.</p>
<p>객체 리터럴에 의해 생성된 객체의 프로토타입은 Object.prototype이고,</p>
<p>생성자 함수에 의해 생성된 객체의 프로토타입은 생성자 함수의 prototype 프로퍼티에 바인딩되어 있는 객체다. </p>
<p>[[Prototype]] 내부 슬롯에는 직접 접근할 수 없지만, <strong>proto</strong> 접근자 프로퍼티를 통해 자신의 프로토타입, 즉 자신의 [[Prototype]] 내부 슬롯이 가리키는 프로토타입에 간접적으로 접근할 수 있다.</p>
<p>그리고 프로토타입은 자신의 constructor 프로퍼티를 통해 생성자 함수에 접근할 수 있고, 생성자 함수는 자신의 prototype 프로퍼티를 통해 프로토타입에 접근할 수 있다.</p>
<h3 id="proto"><a href="#proto" class="headerlink" title="proto"></a><strong>proto</strong></h3><p><strong>모든 객체는 <strong>proto</strong> 접근자 프로퍼티를 통해 자신의 프로토타입, 즉 [[Prototype]] 내부 슬롯에 간접적으로 접근할 수 있다.</strong> </p>
<p><strong>proto</strong> 접근자 프로퍼티는 상속을 통해 사용된다.</p>
<p><strong>proto</strong> 접근자 프로퍼티는 객체가 직접 소유하는 프로퍼티가 아니라 Object.prototype의 프로퍼티다. 모든 객체는 상속을 통해 Object.prototype.<strong>proto</strong> 접근자 프로퍼티를 사용할 수 있다.</p>
<h4 id="Object-prototype"><a href="#Object-prototype" class="headerlink" title="Object.prototype"></a>Object.prototype</h4><p>모든 객체는 프로토타입의 계층 구조인 프로토타입 체인에 묶여 있다. 자바스크립트 엔진은 객체의 프로퍼티(메서드 포함)에 접근하려고 할 때 해당 객체에 접근하려는 프로퍼티가 없다면 <strong>proto</strong> 접근자 프로퍼티가 가리키는 참조를 따라 자신의 부모 역할을 하는 프로토타입의 프로퍼티를 순차적으로 검색한다. </p>
<p>프로토타입 체인의 종점, 즉 프로토타입 체인의 최상위 객체는 Object.prototype이며, 이 객체의 프로퍼티와 메서드는 모든 객체에게 상속된다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<p>Object.create() 함수를 사용하면 해당 객체의 prototype을 지정할 수 있는데 저렇게 명시적으로 지정을 하면 프로토타입으로부터 상속을 받을 수 없다.</p>
<h3 id="생성자-함수-prototype"><a href="#생성자-함수-prototype" class="headerlink" title="생성자 함수 prototype"></a>생성자 함수 prototype</h3><p>함수 객체만이 소유하는 prototype 프로퍼티는 생성자 함수가 생성할 인스턴스의 프로토타입을 가리킨다.</p>
<p>일반 객체는 프로토 타입을 Object.prototype을 가지며,</p>
<p>생성사 함수에 의함 객체는 프로토 타입을 생성자 함수의 prototype로 가진다.</p>
<p>생정자 함수의 prototype은 프로토 타입으로 Object.prototype을 가진다.</p>
<p>Object.prototype -&gt; 생성자 함수 prototype -&gt; 인스턴스</p>
<p>Object.prototype -&gt; 일반 객체  </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://parksaneon.github.io/2020/08/26/first-class-object/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Park facamp">
      <meta itemprop="description" content="All Dev stories">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Park facamp's blog">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/26/first-class-object/" class="post-title-link" itemprop="url">first-class-object</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-08-26 20:11:44 / Modified: 20:14:09" itemprop="dateCreated datePublished" datetime="2020-08-26T20:11:44+09:00">2020-08-26</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="일급객체"><a href="#일급객체" class="headerlink" title="일급객체"></a>일급객체</h1><ul>
<li>무명의 리터럴로 생성할 수 있다. 즉, 런타임에 생성이 가능하다.</li>
<li>변수나 자료구조(객체, 배열 등)에 저장할 수 있다.</li>
<li>함수의 매개변수에게 전달할 수 있다.</li>
<li>함수의 반환값으로 사용할 수 있다.</li>
</ul>
<p>위의 조건을 만족하면 일급 객체라 하는데</p>
<p>자바스크립트 함수 객체의 위의 조건을 모두 충족하므로 일극 객체라 할 수 있다.</p>
<p>함수는 객체이나 일반 객체와는 차이가 있다.</p>
<p>일반 객체는 호출할 수 없지만 <strong>함수 객체는 호출</strong>할 수 있다. 그리고 함수 객체는 일반 객체에는 없는 <strong>함수 고유의 프로퍼티</strong>를 소유한다.</p>
<h3 id="arguments-프로퍼티"><a href="#arguments-프로퍼티" class="headerlink" title="arguments 프로퍼티"></a>arguments 프로퍼티</h3><p>함수 객체의 arguments 프로퍼티 값은 arguments 객체다. </p>
<p>arguments 객체는 함수 호출 시 전달된 인수(argument)들의 정보를 담고 있는 순회 가능한 유사 배열 객체이며, 함수 내부에서 지역 변수처럼 사용된다.</p>
<p>함수가 호출되면 함수 몸체 내에서 암묵적으로 매개변수가 선언되고 undefined로 초기화된 이후 인수가 할당된다.</p>
<p>모든 인수는 암묵적으로 arguments 객체의 프로퍼티로 보관된다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// arguments 객체는 length 프로퍼티가 있는 유사 배열 객체이므로 for 문으로 순회할 수 있다.</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">    res += <span class="built_in">arguments</span>[i];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sum());        <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">1</span>, <span class="number">2</span>));    <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>

<p>유사 배열 객체는 배열이 아니므로 배열 메서드를 사용할 경우 에러가 발생한다.</p>
<p>일반 객체처럼 사용하려면</p>
<ul>
<li><p>Function.prototype.call</p>
</li>
<li><p>Function.prototype.apply</p>
</li>
</ul>
<p>등으로 유사 배열객체를 배열로 변환해 줘야 한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br></pre></td></tr></table></figure>



<h2 id="proto-접근자-프로퍼티"><a href="#proto-접근자-프로퍼티" class="headerlink" title="proto 접근자 프로퍼티"></a><strong>proto</strong> 접근자 프로퍼티</h2><p>모든 객체는 [[Prototype]]이라는 내부 슬롯을 갖는다. [[Prototype]] 내부 슬롯은 객체 지향 프로그래밍의 상속을 구현하는 프로토타입 객체를 가리킨다.</p>
<p><strong>proto</strong> 는 [[Prototype]] 내부 슬롯이 가리키는 프로토타입 객체에 접근하기 위해 사용하는 접근자 프로퍼티다.</p>
<h2 id="prototype-프로퍼티"><a href="#prototype-프로퍼티" class="headerlink" title="prototype 프로퍼티"></a>prototype 프로퍼티</h2><p>prototype 프로퍼티는 생성자 함수만이 소유하는 프로퍼티다. 일반 객체와 생성자 함수로 호출할 수 없는 함수에는 prototype 프로퍼티가 없다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 함수 객체는 prototype 프로퍼티를 소유한다.</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;).hasOwnProperty(<span class="string">&#x27;prototype&#x27;</span>); <span class="comment">// -&gt; true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 일반 객체는 prototype 프로퍼티를 소유하지 않는다.</span></span><br><span class="line">(&#123;&#125;).hasOwnProperty(<span class="string">&#x27;prototype&#x27;</span>); <span class="comment">// -&gt; false</span></span><br></pre></td></tr></table></figure>

<p>prototype 프로퍼티는 함수가 객체를 생성하는 생성자 함수로 호출될 때 생성자 함수가 생성할 인스턴스의 프로토타입 객체를 가리킨다.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://parksaneon.github.io/2020/08/25/life-cycle/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Park facamp">
      <meta itemprop="description" content="All Dev stories">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Park facamp's blog">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/25/life-cycle/" class="post-title-link" itemprop="url">life-cycle</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-08-25 15:55:40 / Modified: 15:57:22" itemprop="dateCreated datePublished" datetime="2020-08-25T15:55:40+09:00">2020-08-25</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="변수-생명주기"><a href="#변수-생명주기" class="headerlink" title="변수 생명주기"></a>변수 생명주기</h1><p>변수는 선언에 의해 생성되고 할당에 의해 값을 할당받는다. 그리고 사용이 끝난 변수는 소멸하는데 이를 생명주기라고 한다.</p>
<p>생명주기가 없다면 변수는 종료를 하지 않는 한 메모리 공간을 계속 점유한다.</p>
<p>전역변수는 웹 어플의 생명주기와 같고 지역변수는 해당 함수가 종료시에 같이 소멸한다. 이는 지역 함수는 함수가 호출되어 실행되는 동안만 생명주기가 유효하다는 의미다.</p>
<h3 id="지역-변수"><a href="#지역-변수" class="headerlink" title="지역 변수"></a>지역 변수</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="string">&#x27;global&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x); <span class="comment">// ①</span></span><br><span class="line">  <span class="keyword">var</span> x = <span class="string">&#x27;local&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br><span class="line"><span class="built_in">console</span>.log(x); <span class="comment">// global</span></span><br></pre></td></tr></table></figure>

<p>호이스팅은 전역 환경에서만 일어나는 것이 아니라, 지역(함수) 환경에서도 일어난다. 따라서 위의 foo 함수에서는 x라는 변수가 먼저 호이스팅 되므로 undefined가 출력된다.</p>
<p>호이스팅은 스코프 단위로 일어난다.지역 변수의 호이스팅은 지역 변수의 선언이 지역 스코프의 선두로 끌어 올려진 것처럼 동작한다. 따라서 지역 변수는 함수 전체에서 유효하다. (변수의 선언이 해당 스코프의 선두로 올라간다는 의미) </p>
<h3 id="전역-변수"><a href="#전역-변수" class="headerlink" title="전역 변수"></a>전역 변수</h3><p>지역변수에 비해 전역변수는 생명주기가 길다. 이것은 메모리 소비가 그만큼 높고, 지역 환경에서 전역 변수 검색시 가장 마지막에 검색이 되어 속도상의 차이도 분명이 존재한다.</p>
<p>이를 방지하기 위해서, 전역대신 즉시실행함수를 이용하여 변수를 선언하거나 전역 환경에 객체를 생성하고 그 객체에 전역 변수처럼 사용할 변수들을 저장하는 방법등이 존재한다.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://parksaneon.github.io/2020/08/24/JS-function/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Park facamp">
      <meta itemprop="description" content="All Dev stories">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Park facamp's blog">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/24/JS-function/" class="post-title-link" itemprop="url">JS function</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-08-24 20:11:13 / Modified: 20:11:49" itemprop="dateCreated datePublished" datetime="2020-08-24T20:11:13+09:00">2020-08-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="함수"><a href="#함수" class="headerlink" title="함수"></a>함수</h1><p>자바스크립트의 핵심 개념인 스코프, 실행 컨텍스트, 클로저, 생성자 함수에 의한 객체 생성, 메서드, this, 프로토타입, 모듈화 등이 모두 함수와 깊은 관련이 있다. </p>
<p>수학에서의 함수는 입력(input) 받은 것을 출력(output)한다는 의미</p>
<p>프로그래밍 에서의 <strong>함수는 일련의 과정을 문으로 구현한 다음 이를 코드블럭으로 감싼 하나의 실행 단위</strong>이다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// f(x, y) = x + y</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// f(2, 5) = 7</span></span><br><span class="line">add(<span class="number">2</span>, <span class="number">5</span>); <span class="comment">// 7</span></span><br></pre></td></tr></table></figure>

<p>자바스크립트에서 함수는 객체로서 하나의 값으로 취급된다.</p>
<p><img src="https://poiemaweb.com/assets/fs-images/12-2.png" alt="img"></p>
<p>함수 이름은 하나의 식별자로서 메모리에 저장된 함수를 가르키는 역활을 한다.</p>
<p>함수는 정의를 통해 만들어지지만 실행을 하려면 호출을 따로 해줘야 한다.</p>
<h3 id="사용-이유"><a href="#사용-이유" class="headerlink" title="사용 이유"></a>사용 이유</h3><ol>
<li><p>필요할 때 언제든지 실행할 수 있다. </p>
<p>동일한 작업을 반복적으로 사용할 때 사용되며 이를 코드의 재사용성이라 한다. -&gt;  사용자가 작성한 코드가 동일하게 사용될 때 함수의 사용을 고려할 수 있다.</p>
</li>
<li><p>함수는 변수처럼 이름을 가질 수 있다.</p>
<p>함수는 여러개의 문을 블록으로 감싼 하나의 실행단위라고 볼 수 있는데, 그 실행의 단위에 대한 이름을 지정하여, 해당 함수가 어떤 일을 하는 지를 쉽게 판별할수 있게 하는데 이를 코드의 가독성이라 한다.</p>
</li>
</ol>
<h3 id="함수-리터럴"><a href="#함수-리터럴" class="headerlink" title="함수 리터럴"></a>함수 리터럴</h3><p>리터럴 : 함수를 생성하는 표기법</p>
<p>자바스크립트의 함수는 객체타입의 값이다.  숫자값을 숫자 리터럴로 생성하는 것처럼 함수도 해당 리터럴로 생성할 수 있다. 함수 리터럴은 function키워드, 함수이름, 매개변수 목록, 함수 몸체 등 4가지로 나타낸다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 변수에 함수 리터럴을 할당</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>함수 이름은 식별자로서 네이밍 규칙을 준수해야 하는데 경우에 따라 생략할 수 있다.</p>
<p>이름의 유무에 따라 기명함수(named function) / 익명함수(anonymous function) 라 불린다.</p>
<p>리터럴이 실행되는 시점에 함수라는 하나의 객체를 생성한다. 함수자체가 값(객체)이므로 변수에 할당이 가능하다.</p>
<p>위에 f라는 변수에는 함수가 저장된 메모리의 주소를 참조값으로 가진다.</p>
<p>함수는 객체이지만 일반적인 객체와는 다르다. 일반객체와 달리 함수는 호출이 가능하고, </p>
<h3 id="함수-정의"><a href="#함수-정의" class="headerlink" title="함수 정의"></a>함수 정의</h3><p>함수를 정의하는 방법은 4가지가 존재한다.</p>
<ol>
<li>함수 선언 : 함수 리터럴을 어디에도 할당하지 않고 정의만 내림</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol start="2">
<li>함수 표현식 : 함수 리터럴을 변수에 할당</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<ol start="3">
<li>Fuction 생성자 함수</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> add = <span class="keyword">new</span> Fuction()</span><br></pre></td></tr></table></figure>



<ol start="4">
<li>화살표 함수</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> add = <span class="function">(<span class="params">x, y</span>) =&gt;</span> x + y;</span><br></pre></td></tr></table></figure>



<h3 id="함수-선언문"><a href="#함수-선언문" class="headerlink" title="함수 선언문"></a>함수 선언문</h3><p>함수 리터럴을 이용해 함수를 정의하고, 따로 변수에 함수를 할당하지 않는다. ( 함수 이름 생략 불가능 )</p>
<p>함수 선언문은 표현식이 아닌 문이다.( 값으로 평가될 수 없다 )</p>
<p>그런데 함수 선언문은 변수에 할당해도 정상적으로 동작하는 것으로 보여진다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수 호출</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">2</span>, <span class="number">5</span>)); <span class="comment">// 7</span></span><br></pre></td></tr></table></figure>

<p>자바스크립트 엔진은 함수 선언문이 변수에 할당되지 않으면 함수 선언문으로 해석한다.</p>
<p>반면에 변수에 할당하면, 함수 선언문에 이름이 존재해도 함수 선언문이 아닌, 함수 표현식으로 해석한다.</p>
<p>원래 함수 식별자는 함수 코드블럭 내부에서만 참조가 가능하다. 그런데 외부에서도 함수 식별자를 통한 선언이 가능한 이유는 함수 선언문을 실행할 때, 암묵적으로 선언문의 함수 이름과 동일한 이름의 변수를 생성하고 해당 변수에 생성된 함수 객체를 할당하기 때문이다.</p>
<p>결론적으로 함수를 실행할 때는 해당 함수 명이 아니라 해당 함수가 할당된 함수명과 동일한 변수를 통해 실행하는 것이다.</p>
<p>-&gt; <strong>함수는 함수 이름이 아니라 함수 객체를 가르키는 식별자로 호출한다</strong></p>
<p><img src="https://poiemaweb.com/assets/fs-images/12-7.png" alt="img"></p>
<h3 id="함수-표현식"><a href="#함수-표현식" class="headerlink" title="함수 표현식"></a>함수 표현식</h3><p>함수 리터럴로 생성한 함수를 변수에 할당한다. </p>
<p>함수 리터럴에서 함수 이름은 생략이 가능하다. (함수 선언문은 함수이름과 동일한 변수를 암묵적으로 생성해야 하기때문에 생략이 불가)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 함수 표현식</span></span><br><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>함수는 일급객체로서 값처럼 자유롭게 사용이 가능하다. ( 변수에 할당하는 것도 가능 ) </p>
<p>함수이름은 해당 함수 코드블럭내에서만 참조가 가능하다.</p>
<p>엔진의 암묵적인 동일 변수생성이 없다면 외부에서 실행이 불가능하다. </p>
<h3 id="함수-생성-시점과-함수-호이스팅"><a href="#함수-생성-시점과-함수-호이스팅" class="headerlink" title="함수 생성 시점과 함수 호이스팅"></a>함수 생성 시점과 함수 호이스팅</h3><p>함수 선언문은 선언문 이전에 함수를 실행하면 함수 호이스팅에 의해 정상적으로 동작하지만, 함수 표현식은 이전에 실행시 변수 호이스팅이 일어나 동작하지 않는다.</p>
<p>함수 선언문은 자바스크립트 런타임(위에서 아래로 순차적 실행)이 아닌 런타임이전에 먼저 선언문을 실행한다. ( 변수 선언문도 마찬가지 )</p>
<p>즉 함수 선언문은 런타임 이전에 실행되어 함수 객체가 미리 생성된다. 반면 함수 표현식은 런타임에 의해 해당 줄이 실행될 때 변수에 할당된다.</p>
<h3 id="Fuction-생성자-함수"><a href="#Fuction-생성자-함수" class="headerlink" title="Fuction 생성자 함수"></a>Fuction 생성자 함수</h3><p>생성자 함수란 객체를 생성하는 함수를 말한다.</p>
<p>함수또한 객체이므로 생성자 함수를 통해서 생성된다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> add = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;return x + y&#x27;</span>); <span class="comment">// 매개변수1, 매개변수2, 함수 몸체</span></span><br></pre></td></tr></table></figure>

<p>일반적으로 권장되는 방법은 아니다.</p>
<h3 id="화살표-함수"><a href="#화살표-함수" class="headerlink" title="화살표 함수"></a>화살표 함수</h3><p>function이라는 키워드 대신 화살표 =&gt; 를 사용해 함수를 선언한다. 화살표 함수는 항상 익명함수로 정의한다.</p>
<h2 id="함수호출"><a href="#함수호출" class="headerlink" title="함수호출"></a>함수호출</h2><p>함수 객체를 가르키는 식별자와 한 쌍의 소괄호인 함수 호출 연산자로 실행한다. 소괄호 안에는 0개 이상의 매개변수가 들어간다. 함수가 호출되면 기존 실행 흐름을 중단하고 호출된 함수로 컨트롤이 옮겨진다.</p>
<p>매개변수는 순서대로 할당된다.</p>
<p><img src="https://poiemaweb.com/assets/fs-images/12-9.png" alt="img">함수외부에서 내부로 필요한 값을 전달할 경우는 매개변수를 통해 인수를 전달한다.</p>
<p>인수는 값이어야 하고 타입에는 제한이 없다.</p>
<p>일반적으로 변수는 변수 키워드와 같이 선언하고 런타임 이전에 실행되지만, 매개변수는 함수가 호출된 직후에 실행된다. 이때 초기에는 undefined로 초기화 되었다가 인수 전달을 통해 해당 값을 할당받는다.</p>
<p>자바스크립트는 매개변수와 인수의 수를 체크하지 않는다. 정의된 매개변수보다 인수의 수가 작을 경우엔 나머지 매개변수는 undefined로 유지되며, 더 큰 경우에는 무시되고 그 값들은 arguments 객체에 보관된다.</p>
<p>매개변수는 가능하면 최대 3개 이상을 넘지 않도록 하며, 불가피하게 인수를 많이 전달해야 하는 경우에는 객체나 배열을 이용하여 많은 값을 한 인수에 포함하도록 한다.</p>
<h3 id="반환문"><a href="#반환문" class="headerlink" title="반환문"></a>반환문</h3><p>함수는 반환 키워드 return과 반환값으로 이뤄진 반환문을 통해 실행 결과를 함수 외부로 반환한다.</p>
<p>return 키워드는 함수 외부로 값을 반환하는 것 외에도 함수 실행을 종료하는 기능도 가진다. 반환문 이후에 등장하는 문들은 아무 의미가 없는 문이다. </p>
<p>return을 생략하거나 반환값을 지정하지 않으면 암묵적으로 undefined를 반환한다.</p>
<h3 id="즉시-실행함수"><a href="#즉시-실행함수" class="headerlink" title="즉시 실행함수"></a>즉시 실행함수</h3><p>함수의 정의와 동시에 즉시 호출되는 함수로서 단 한번만 호출되고, 다시 호출할수 없다. 다시 호출이 불가능하므로 함수 이름 생략이 가능하여 익명함수로 사용한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure>

<p>즉시 실행 함수는 반드시 그룹 연사자 () 감싸 줘야 줘야 한다.</p>
<p>그룹 연산자 내부의 함수 리터럴은 함수 표현식으로 동작한다 ( 선언문 x )</p>
<p>그룹 연산자 내부의 함수 표현식은 함수 리터럴로 평가되어 객체가 된다. 객체가 생성됨과 동시에 () 키워드로 함수가 실행된다.  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">!<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line">+<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure>

<p>함수 호출 키워드 소괄호()는 그룹연산자의 외부/내부 어느곳에 위치해도 정상동작 한다.</p>
<p>인수를 전달할 때는 함수 호출 키워드 소괄호() 내부에 작성하면 된다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 즉시 실행 함수에도 일반 함수처럼 인수를 전달할 수 있다.</span></span><br><span class="line">res = (<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;(<span class="number">3</span>, <span class="number">5</span>));</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// 15</span></span><br></pre></td></tr></table></figure>



<h3 id="재귀함수"><a href="#재귀함수" class="headerlink" title="재귀함수"></a>재귀함수</h3><p>함수는 자기 자신을 호출할 수 있는데 이를 재귀함수라고 부른다.</p>
<p>자기 자신을 호출하는 행위이며 재귀 호출을 통해 반복 연산을 구현할 수 있다.</p>
<p>재귀함수는 그냥 사용하면 무한하게 자신을 호출하므로 어느시점에서는 자기 호출을 중단하도록 탈출 조건을 걸어줘야 한다. ( stack overflow 오류 발생 방지 )</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://parksaneon.github.io/2020/08/24/position-minus-margin/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Park facamp">
      <meta itemprop="description" content="All Dev stories">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Park facamp's blog">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/24/position-minus-margin/" class="post-title-link" itemprop="url">position & minus margin</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-08-24 16:29:54 / Modified: 16:30:24" itemprop="dateCreated datePublished" datetime="2020-08-24T16:29:54+09:00">2020-08-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>content-box </p>
<p>width 에 padding, border, margin을 모두 더하는 방식</p>
<p>border-box</p>
<p>width 에 padding, border까지 포함하여 적용되는 방식</p>
<h2 id="Position"><a href="#Position" class="headerlink" title="Position"></a>Position</h2><p>static을 제외한 postion 속성 값 모두 offset 값으로 위치값을 지정해준다.</p>
<p>-&gt; top, left, right, bottom</p>
<p>postion 속성에서 static, relative 값들은 normal flow 흐름을 따라 가지만 absolute, fixed 등은 적용 즉시 레이어 라는 개념으로 컨텐츠 위로 뜬다.</p>
<p>absoulte 값 지정시 offset값을 지정해주지 않으면 자신의 위치에서 위쪽으로 뜬다.</p>
<h5 id="position-위치-기준"><a href="#position-위치-기준" class="headerlink" title="position 위치 기준"></a>position 위치 기준</h5><p>absolute : 부모 태그 중 static 을 제외한 postion값을 가진 부모 태그 기준</p>
<p>relative : 자기 자신의 위치가 기준</p>
<p>fixed : viewport 기준</p>
<p>absoulte의 부모 태그에 relative 값을 주로 주는데 normal flow를 벗어나지 않으면서 위치값 지정이 가능하기 때문이다.</p>
<h2 id="absolute와-float-비교"><a href="#absolute와-float-비교" class="headerlink" title="absolute와 float 비교"></a>absolute와 float 비교</h2><p>absolute와 float는 모두 normal flow를 벗어난다.</p>
<h4 id="absolute"><a href="#absolute" class="headerlink" title="absolute"></a>absolute</h4><ul>
<li>레이어이기 때문에 absolute 위에 absolute가 겹칠 수가 있다. ( z-index )</li>
<li>논리적인 흐름상에 있는 line 속성 위에 떠 있을 때 line 속성을 가린다.</li>
</ul>
<h4 id="float"><a href="#float" class="headerlink" title="float"></a>float</h4><ul>
<li><strong>보모 크기만큼의 line box</strong>가 생기면서 논리적인 흐름을 벗어나고, 레이어가 아니기때문에 absolute처럼 겹치지 않는다.</li>
<li>논리적인 흐름상에 있는 inline 속성 위에 떠 있을 때 inline 속성을 밀어낸다. ( block 영역은 밀어내지 못함 )</li>
</ul>
<h3 id="Negative-Margin"><a href="#Negative-Margin" class="headerlink" title="Negative Margin"></a>Negative Margin</h3><p>margin은 padding과 달리 auto라는 값이나 음수 값을 가질 수 있다.</p>
<p>block                                                                                                                                          유의미한 변화는 bold처리</p>
<ul>
<li><p><strong>block 이며 width가 auto 일 때</strong> </p>
<p><strong>marin-top</strong> :값이 음수일 경우 - 수치 만큼 위치가 위쪽으로 이동한다. margin-bottom에 -값을 줬을 경우 아무 일도 일어나지 않는다.</p>
<p><strong>magin-right</strong>나 <strong>margin-left</strong>에 - 값을 줬을 경우 - 값만큼 너비가 늘어난다.</p>
<p>기본적으로 block은 width값이 auto라서 부모크기 만큼의 width가 설정되는데 right나 left에 - 값을 주면 수평선 상으로 시작하는 지점이나, 끝나는 지점을 속여 바뀐 위치에서 width가 100%로 되는 것</p>
</li>
</ul>
<ul>
<li><p><strong>block 이며 width가 고정 값일 때</strong></p>
<p><strong>margin-top</strong> 에 -값을 줄 경우 위쪽으로 위치가 이동하며 bottom에는 줘도 아무 일도 일어나지 않는다.</p>
<p>기본적으로 위치는 왼쪽 화면 끝에 고정되어 있는데 이때 right에다 -값을 줘도 역시 아무런 변화가 없다.</p>
<p>단, <strong>left</strong>에 -를 주면 위치가 왼쪽으로 이동한다.</p>
</li>
</ul>
<p>inline-block</p>
<ul>
<li>top, bottm은 - 값을 줘도 변화가 없고 <strong>left</strong>는 값을 주면 값이 왼쪽으로 일어난다.</li>
<li><strong>left</strong>는 값을 줄 경우 형제 요소가 - 값만큼 왼쪽으로 이동한다. 이때 본인만 이동하는것이 아닌 수평 위치의 형제요소들도 왼쪽으로 같이 이동한다.</li>
</ul>
<p>float</p>
<ul>
<li><p><strong>top</strong>에 -값을 주면 위치가 위쪽으로 이동한다. bottm은 - 값을 줘도 변화가 없다.</p>
<p><strong>left</strong>, <strong>right</strong>는 -값 적용시 inline-block 과 같이 동작한다.</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">float, inline 요소에 음수 right 마진을 사용하면 이 요소의 너비가 음수 마진 만큼 줄어들게 된다.</span><br><span class="line">* 그렇기 때문에 다음에 따라오는 요소가 끌려 가는 효과가 나타나게 된다.</span><br></pre></td></tr></table></figure>





<p>abolute</p>
<ul>
<li>top, right, bottm 모두 변화가 없고 <strong>left</strong>에 - 값을 주면 왼쪽으로 이동한다.</li>
</ul>
<p>정리하면 nagative margin 은</p>
<p>left ,right 등에 - 값 적용시 위치가 이동하는 것은 시작, 끝나는 원래 위치에서  수치만큼의 위치에서 시작, 끝나는 것으로 브라우저를 속인다고 생각하면 될 거 같다.</p>
<p>( 수평선 상에서 )</p>
<p>margin-left : 요소가 더 빨리 시작하도록 ( 브라우저를 속인다. )</p>
<p>margin-right : 요소가 더 빨리 끝나도록 </p>
<p>(수직 상에서)</p>
<p>margin-top : 요소가 더 빨리 시작하도록 시작점을 속이는 것</p>
<p>margin-bottom : 요소가 더 빨리 끝나도록  끝나는 지점을  속이는 것</p>
<p>( - 값만큼 더 빨리 시작하거나, 빨리 끝난다는 것으로 생각하자 )</p>
<p>예외적으로 block(width : auto;) 의 경우에는 magin-right나 margin-left에 - 값을 줬을 경우 - 값만큼 너비가 늘어난다. 이것은 blcok 요소는 기본적으로 widht값이 auto이기 때문에 부모크기 만큼 width가 설정되는데 </p>
<p>marign right나 left에 - 값을 주면 수평선 상으로 시작하는 지점이나, 끝나는 지점을 속여 바뀐 위치에서 width가 100%로 되는 것으로 이해하자</p>
<p>inline-block 에 아무런 내용이 없을 경우 vertical-align 속성 기본값이 baseline인 것에 따라 내용이 없는 것으로 인해 동작을 안하므로 vertical-align을 top, bottom 등 다른 속성값을 제공하거나 내용을 넣어주어야 원하는 대로 동작한다. </p>
<p>inheritance ( 상속 )</p>
<p>부모의 속성이 자식에게 상속되는 개념</p>
<p>negative margin</p>
<p>block 태그에 margin 속성값을 마이너스로 주면 너비가 그만큼 증가한다.</p>
<p>form 관련</p>
<p>a[href], area[href]</p>
<p>tabindex = ‘0’</p>
<p>aria-</p>
<p>role =”button”</p>
<p>button 태그는 type속성을 지정안하면 type=’submit’ 속성이 기본값으로 지정된다.</p>
<p>display : none 속성의 태그는 스크린리더 등 보조기기기 인식하지 못한다.</p>
<p>width : 0 ; height : 0 처럼 너비, 높이가 0이어도 인식하지 못한다.</p>
<p>border-left: 2px solid rgba(255,255,255, 0.5); - </p>
<p>​                                      선 이름 영역에 rgba() 함수를 사용하여 불투명 선을 주는 것도 가능</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://parksaneon.github.io/2020/08/24/ARIA-float/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Park facamp">
      <meta itemprop="description" content="All Dev stories">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Park facamp's blog">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/24/ARIA-float/" class="post-title-link" itemprop="url">ARIA & float</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-08-24 16:28:12 / Modified: 16:28:25" itemprop="dateCreated datePublished" datetime="2020-08-24T16:28:12+09:00">2020-08-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="ARIA"><a href="#ARIA" class="headerlink" title="ARIA"></a>ARIA</h2><p><strong>접근가능한 리치 인터넷 어플리케이션</strong>(Accessible Rich Internet Applications, <strong>ARIA</strong>)</p>
<p>장애를 가진 사용자가 웹 콘텐츠와 웹 어플리케이션에 더 쉽게 접근할 수 있는 방법을 정의하는 여러 특성을 가르킨다.</p>
<p>ARIA는 HTML을 보충해 사용자에게 추가적인 정보를 제공한다.</p>
<p>ARIA 속성을 사용한다면  **여분의 레이블 및 설명 텍스트 **를 추가할 수 있다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button aria-label&#x3D;&quot;screen reader only label&quot;&gt;&lt;&#x2F;button&gt;</span><br></pre></td></tr></table></figure>



<p>ARIA는 특정 영역을 제어하는 사용자설정 스크롤 바와 같은 표준 상위/하위 연결을 확장하는 <strong>요소 간의 의미 체계 관계</strong>를 표현할 수 있다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div role&#x3D;&quot;scrollbar&quot; aria-controls&#x3D;&quot;main&quot;&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>



<h2 id="float"><a href="#float" class="headerlink" title="float"></a>float</h2><p>Float를 설정하면 기존의 BFC의 동작을 무시하고 새로운 BFC를 생성한다. line box 시스템을 이용하여 그려지게 되는데, 기존의 BFC에 영향을 받지 않기 때문에 떠있는 것 처럼 보여 속성 이름이 float가 되었다. </p>
<p>이는 새로운 bfc의 시작이며, line-box는 float 속성을 가진 요소들만 관리하게 된다. 즉, flow요소와 아닌 요소가 같이 있다면 서로 다른 bfc에 존재한다는 것입니다.</p>
<p>또한 돔구조에 관계없이 인라인 요소를 밀어내도록 작용하므로 block요소는 아래 이미지처럼 파란 영역은 float의 영향을 받고 밀려나지 않지만 그 안에 있는 텍스트 인라인 요소는 float에 밀려서 표현된 것을 알 수 있다.</p>
<p><img src="https://media.vlpt.us/images/susu1991/post/4241c165-9d53-4306-9a1d-b6a36037cd4a/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202020-03-25%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%202.23.40.png" alt="img"></p>
<p>line-box는 어느 방향이던, 그 방향의 마지막요소보다 더 그 방향쪽으로 나아갈 수 없으며 마지막 요소가 끝나는 지점부터 그려지기 시작한다.</p>
<p>또 이미 그려진 영역은 새로운 요소가 그려질 영역에서 계산 제외되며, 수직방향의 기준은 가장 마지막 line-box 바로 아래에 그려진다.</p>
<p>Block Box &gt; Line Box &gt; Inline Box</p>
<p>부모 태그에 overflow : hidden속성을 주어 float된 자식의 높이값을 가지게 하는 것은 float 관련 문제의 해결방법중 하나다.( 권장 사항은 아니다 )</p>
<p>float된 요소가 새로운 BFC를 생성하여 그곳에서 배치가 되는데 overflow hidden 역시 독자적으로 BFC를 생성한다. BFC는 자기의 자식은 포함하여 표현해야하는 책임을 가져 float된 자식이라도 높이 값을 인식하게 된다.</p>
<p>( BFC 생성 시 line-box 의 경계를 인식하여 높이를 가진다라는 스펙또한 있음 )</p>
<p>BFC는 자기의 자식은 포함하여 표현해야하는 책임은 있지만 그 안에서 새로운 BFC가 생성이 된다면 그 하위의 자식까지는 표현하지 않는다.</p>
<h2 id="BFC-amp-IFC"><a href="#BFC-amp-IFC" class="headerlink" title="BFC &amp; IFC"></a>BFC &amp; IFC</h2><p>한줄을 어떻게 차지하는 지에 대한 차이에 따라 나눈다.</p>
<h4 id="BFC-Block-Formatting-Context"><a href="#BFC-Block-Formatting-Context" class="headerlink" title="BFC(Block Formatting Context)"></a>BFC(Block Formatting Context)</h4><p>block 레벨 엘리먼트와 같이 요소를 세로로 배치하는 컨텍스트</p>
<p>자신의 부모만큼의 너비를 가지며 안에 있는 블럭요소의 높이 만큼의 높이를 가진다. </p>
<p>( width : 100% ; height : auto; )</p>
<h4 id="IFC-Inline-Formatting-Context"><a href="#IFC-Inline-Formatting-Context" class="headerlink" title="IFC(Inline Formatting Context)"></a>IFC(Inline Formatting Context)</h4><p>inline 레벨 엘리먼트와 같이 요소를 가로로 배치하는 컨텍스트</p>
<p>너비와 높이 모두 해당 inline태그의 content크기 만큼만 가진다. inline width의 합이 부모요소의 width 값을 넘었을 때 밑으로 떨어진다.</p>
<p>( width : auto; height : auto; )</p>
<p>BFC는 BFC영역에서 요소들을 세로 배치할 수 있도록 위치를 계산해 알려주고, IFC는 IFC영역에서 요소들을 가로로 배치할 수 있도록 위치를 계산해 알려주는 것이다.</p>
<p>참고 자료</p>
<p><a target="_blank" rel="noopener" href="https://www.bsidesoft.com/3634">https://www.bsidesoft.com/3634</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://parksaneon.github.io/2020/08/24/Box-model-float/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Park facamp">
      <meta itemprop="description" content="All Dev stories">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Park facamp's blog">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/24/Box-model-float/" class="post-title-link" itemprop="url">Box model & float</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-08-24 16:23:12 / Modified: 16:24:09" itemprop="dateCreated datePublished" datetime="2020-08-24T16:23:12+09:00">2020-08-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Box-Model"><a href="#Box-Model" class="headerlink" title="Box Model"></a>Box Model</h1><p>content &gt; padding &gt; border &gt; margin</p>
<h5 id="auto-값"><a href="#auto-값" class="headerlink" title="auto 값"></a>auto 값</h5><p>block 태그 값은 한 줄을 꽉 차지하기 위해 margin 속성을 auto 값으로 가져 한 줄을 다 차지한다.</p>
<p>padding은 auto값을 가지지 못함</p>
<p>margin은 auto 값을 가지는데 박스의 해당 크기에서 나머지 영역을 margin 영역으로 가져서 가능함</p>
<h5 id="vsc-단축키"><a href="#vsc-단축키" class="headerlink" title="vsc 단축키"></a>vsc 단축키</h5><p>shift + alt + 아래방향키 : 선택한 라인 복사해서 다음 줄에 붙여넣기</p>
<p>shift + ctrl + k : 커서가 있는 라인 지우기</p>
<h5 id="float-동작-방식"><a href="#float-동작-방식" class="headerlink" title="float 동작 방식"></a>float 동작 방식</h5><p>nomalflow : 컨텐츠가 순서대로 배치되는데 레이아웃 작업시 여기서 floating, positioning 작업이 일어난다.</p>
<p>float된 컨텐츠마다 각각의 line box 가진다. 각 박스마다 한 줄이 꽉차게 line box를 가질 때 기존 float 영역과 겹치는 것이 불가능 하므로 그 옆으로 배치된다. </p>
<p>float된 박스는 너비, 높이 지정을 않하면 자동적으로 컨텐츠 크기 만큼으로 크기, 높이가 줄어든다.</p>
<p>자식이 float이 될 때 보모 요소는 자식의 높이를 잃어 버린다.</p>
<p>단, float된 부모 요소는 float된 자식의 높이가 반영된다. 자식 float 요소는 BFC 영역을 생성하여 부모 float 요소의 높이에 영향을 주기 때문이다.</p>
<h5 id="LineBox"><a href="#LineBox" class="headerlink" title="LineBox"></a>LineBox</h5><ul>
<li><p>Float 는 LineBox공식으로 그려진다.</p>
</li>
<li><p>Normal Flow 는 BFC, IFC, Relative positioning 으로 그려진다.</p>
</li>
<li><p>기존 영역에 Float 가 차지 해 있으면 사용 가능 한 LineBox 의 영역은 줄어 든다.</p>
</li>
<li><p>LineBox 가 다 차지 하면 남아 있는 <strong>Line Box의 (가장 가까운)하단을 기준</strong>으로 LineBox 가 된다.</p>
<p>해당 lineBox보다 먼저 끝나게 되는 baseLine float를 만나고 해당 박스 아래에 공간이 있을 때</p>
</li>
<li><p>lineBox는 가로 뿐 아니라 세로도 판단한다.</p>
</li>
<li><p>inline 과 text는 normal flow BFC 영역(float의 BFC 가 겹침)이 지정되면 남은 lineBox 에 차지 한다.</p>
</li>
<li><p>base line 기준으로 가능 한 범위 내에 float 가 위치하게 된다.</p>
</li>
<li><p>Text, line Guard 만 적용 될분 Geometry 는 존재 하지 않는다.( 그냥 bfc 한줄만 존재하고 글자만 line Guard 규칙에 의해서 그려진다.</p>
</li>
<li><p>(마지막 ABC8은 7이 float: left 이기 때문에 왼쪽으로는 그리지 못한다.)</p>
</li>
</ul>
<h5 id="float-관련-문제-해결방안"><a href="#float-관련-문제-해결방안" class="headerlink" title="float 관련 문제 해결방안"></a>float 관련 문제 해결방안</h5><p>overflow : hidden - visible값이 아닌 값을 주면 독립적인 BFC 영역을 가지면서 float 자식의 높이 값을 가지게 해준다. (영역 밖으로 내용이 넘치면 안 보인다는 단점이 있다.)</p>
<p>BFC는 그 안에 만들어진 모든 요소를 포함하기 때문이다</p>
<p>가상요소 :  ::before, ::after </p>
<p>​                    태생적으로 inline 속성이다.</p>
<p>​                    clear:both 속성은 inline 태그는 가져도 적용이 안되므로 block 속성으로 변경이 필요하다.</p>
<pre><code>                실제하지 않은 태그이므로 dom에 의한 조작이 불가능하다.</code></pre>
<p>​                    가상의 요소이므로 실체를 가지기 위해서 content 속성 값이 필요 - </p>
<p>​                    <strong>content 속성값이 없다면 태그를 생성하지 못한다.</strong></p>
<p>clearfix : both 속성은 부모태그에 after라는 가상요소를 만들어 거기에 적용시키는 것이 일반적이다.</p>
<h5 id="기타용어"><a href="#기타용어" class="headerlink" title="기타용어"></a>기타용어</h5><p>repaint reflow :</p>
<p>line box : 부모 너비에서 paddding값을 제외한 만큼의 너비로 생성된다. </p>
<p><strong>BFC</strong>( Block Formatting Context ) : 부모의 가로 길이를 가득 채운 한 줄</p>
<p>​        -&gt; width는 항상 부모의 width 값이며 height는 auto값</p>
<p><strong>IFC</strong>( Inline Formatting Context ) : 나의 컨텐츠 크기만큼 가로를 차지한다. </p>
<p>​    - 그 다음 IFC는 이전 IFC의 가로 길이만큼 떨어진 자리에 x가 결정된다. </p>
<p>​    - inline width의 합이 부모의 width를 넘기면 다음줄로 넘어간다.</p>
<p>​    - 다음줄로 얼마나 넘어가야하나? </p>
<p>=&gt; inline을 구성하는 것중 가장 height가 큰것이 lineheight가 되어서 lineheight만큼 y값이 내려온다.</p>
<p>Node : 문서의 객체를 이루는 가장 작은 단위</p>
<p>DOM( Document Object Model ) : 문서 설계도</p>
<h5 id="기타내용"><a href="#기타내용" class="headerlink" title="기타내용"></a>기타내용</h5><p>aria-hidden : true - 화면에는 보이나 스키린 리더기와 같은 기기에서는 읽어주지 않는 속성 </p>
<p>​                                  ( 꾸밈 용도 태그에 작성한다. )</p>
<p>아래 처럼 특정 목적을 위해 작성한 코드는 별도의 css 파일로 따로 관리하는 것이 좋다.</p>
<p>.clearfix::after{</p>
<p>​     content: “”;</p>
<pre><code> clear: both;

 display: block;</code></pre>
<p>}</p>
<p>git push origin –delete 삭제 브렌치명</p>
<p>git push origin 추가 브렌치명</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://parksaneon.github.io/2020/08/14/CSS3-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Park facamp">
      <meta itemprop="description" content="All Dev stories">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Park facamp's blog">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/14/CSS3-2/" class="post-title-link" itemprop="url">CSS3-2</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-08-14 14:27:04 / Modified: 14:27:18" itemprop="dateCreated datePublished" datetime="2020-08-14T14:27:04+09:00">2020-08-14</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="네이밍"><a href="#네이밍" class="headerlink" title="네이밍"></a>네이밍</h3><ul>
<li>id ( # )</li>
<li>class ( . )</li>
</ul>
<p>안 좋은 네이밍은 box1, box2 등 직관적이지 않은 명칭으로 네이밍 하는 것.</p>
<h4 id="네이밍-규칙"><a href="#네이밍-규칙" class="headerlink" title="네이밍 규칙"></a>네이밍 규칙</h4><ul>
<li>p.c - 단어의 첫글자를 무조건 대문자로 작성한다.<ul>
<li>ex) MainContent</li>
</ul>
</li>
<li>c.c -  첫번째 단어는 소문자로 작성하고 두번째 부터 대문자로 작성한다.<ul>
<li>ex) mainContent</li>
</ul>
</li>
<li>k.c  - 단어 중간에 하이픈( - ) 삽입<ul>
<li>main-content</li>
</ul>
</li>
<li>s.c - 단어 중간에 언더바( _ ) 삽입<ul>
<li>main_content</li>
</ul>
</li>
</ul>
<h4 id="CSS-방법론"><a href="#CSS-방법론" class="headerlink" title="CSS 방법론"></a>CSS 방법론</h4><ul>
<li><strong>SMACSS</strong>(Scalable Modular Architecture CSS)</li>
<li><strong>OOCSS</strong>(Object Oriented CSS)</li>
<li><strong>BEM</strong> (Block Element Modifier)</li>
</ul>
<p>CSS 규칙은 하나의 예시일 뿐이고 절대적인 것은 아니다.</p>
<p>한 페이지를 감싸는 div태그는 보통 wrapper, container 등의 class 명칭이 붙는다.</p>
<h2 id="배치"><a href="#배치" class="headerlink" title="배치"></a>배치</h2><ul>
<li><p>float</p>
</li>
<li><p>postition : 좌표로 콘텐츠 배치</p>
</li>
<li><p>flex : float의 단점을 보완하는 1차원 배치</p>
</li>
<li><p>gird : flex의 단점을 보충하는 2차원 배열이 가능하나 아직 지원하는 브라우저가 얼마 없다. ( IE 11 )</p>
</li>
</ul>
<p> div.group.group${group$}*3</p>
<p>server와 client 는 요청과 응답의 연속이다.</p>
<h2 id="CSS-관련-이슈"><a href="#CSS-관련-이슈" class="headerlink" title="CSS 관련 이슈"></a>CSS 관련 이슈</h2><ul>
<li>상속<ul>
<li>em 단위는 부모 태그의 글자 크기를 상속받는다.<ul>
<li>태그를 중첩해서 사용하다 보면 예기치 못한 문제가 발생한다.</li>
</ul>
</li>
<li>rem단위는 html 태그의 글자 크기만을 상속받는다.( 구형 브라우저는 rem 단위를 지원하지 않는다. )</li>
<li>자식 태그는 해당 부모태그의 inline관련 속성(font)을 대부분 상속받으므로 이를 신경써야 한다.</li>
</ul>
</li>
<li>겹침</li>
<li>우선순위</li>
</ul>
<h3 id="CSS-내장-함수"><a href="#CSS-내장-함수" class="headerlink" title="CSS 내장 함수"></a>CSS 내장 함수</h3><p>@impot url() -&gt; url() 함수안에 주소값을 인자로 작성하여 해당 파일을 가져올 수 있다.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



      

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Park facamp</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

      








    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.0/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  















  

  

</body>
</html>
